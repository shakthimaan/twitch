* 1. Tour of OCaml

Reference: https://ocaml.org/docs/tour-of-ocaml

Integer

#+BEGIN_SRC ocaml
50 ;;
50 * 50 ;;
#+END_SRC

Float

#+BEGIN_SRC ocaml
6.28 ;;
3.14 ;;
#+END_SRC

String

#+BEGIN_SRC ocaml
"This is really disco!" ;;
#+END_SRC

Boolean

#+BEGIN_SRC ocaml
true ;;
#+END_SRC

List of integers

#+BEGIN_SRC ocaml
let u = [1; 2; 3; 4] ;;
#+END_SRC

List of strings

#+BEGIN_SRC ocaml
["this"; "is"; "mambo"] ;;
#+END_SRC

Prepend to List

#+BEGIN_SRC ocaml
5 :: u ;;
#+END_SRC

If else construct

#+BEGIN_SRC ocaml
2 * if "hello" = "world" then 3 else 5 ;;
#+END_SRC

Let binding

#+BEGIN_SRC ocaml
let x = 50 ;;
#+END_SRC

Let scope

#+BEGIN_SRC ocaml
let y = 50 in y * y ;;
y ;;
#+END_SRC

Let in expression

#+BEGIN_SRC ocaml
let a = 1 in
let b = 2 in
  a + b ;;
#+END_SRC

Functions

#+BEGIN_SRC ocaml
let square x = x * x ;;

square 50 ;;

square ;;
#+END_SRC

Anonymous Functions

#+BEGIN_SRC ocaml
fun x -> x * x ;;
#+END_SRC

Partial Function Application

#+BEGIN_SRC ocaml
let cat a b = a ^ " " ^ b ;;

cat "ha" "ha" ;;

let cat_hi = cat "hi" ;;

cat_hi "friend" ;;
#+END_SRC

Higher order functions

#+BEGIN_SRC ocaml
List.map ;;

List.map (fun x -> x * x) ;;

List.map (fun x -> x * x) [0; 1; 2] ;;
#+END_SRC

Side Effects

#+BEGIN_SRC ocaml
print_endline ;;

print_endline "Hello" ;;
#+END_SRC

Recursive Functions

#+BEGIN_SRC ocaml
let rec range lo hi =
  if lo > hi then []
  else lo :: range (lo + 1) hi ;;

range 2 5 ;;
#+END_SRC

* 2. Tour of OCaml (...)

Reference: https://ocaml.org/docs/tour-of-ocaml

Type Conversion and Type-Inference

#+BEGIN_SRC ocaml
2.0 +. 2.0 ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 + 2.5 ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 +. 2.5 ;;
#+END_SRC

#+BEGIN_SRC ocaml
float_of_int 1 *. 2.5 ;;
#+END_SRC

Lists

#+BEGIN_SRC ocaml
[] ;;

[1; 2; 3] ;;

[false; false; true] ;;

[[1;2]; [3]; [4;5;6]] ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 :: [2; 3; 4] ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec sum u =
  match u with
  | [] -> 0
  | x :: v -> x + sum v ;;

sum [1; 4; 3; 2; 5] ;;
#+END_SRC

Polymorphic Functions on Lists

#+BEGIN_SRC ocaml
let rec length u =
  match u with
  | [] -> 0
  | _ :: v -> 1 + length v ;;

length [1; 2; 3; 4] ;;

length ["cow"; "sheep"; "cat"] ;;

length [[]] ;;
#+END_SRC

Higher-Order Function

#+BEGIN_SRC ocaml
let square x = x * x ;;

let rec map f u =
  match u with
  | [] -> []
  | x :: u -> f x :: map f u ;;

map square [1; 2; 3; 4] ;;
#+END_SRC

Pattern Matching (...)

#+BEGIN_SRC ocaml
#show option ;;

let f opt = match opt with
  | None -> None
  | Some None -> None
  | Some (Some x) -> Some x ;;
#+END_SRC

#+BEGIN_SRC ocaml
let g x =
  if x = "foo" then 1
  else if x = "bar" then 2
  else if x = "baz" then 3
  else if x = "qux" then 4
  else 0 ;;

let g' x = match x with
  | "foo" -> 1
  | "bar" -> 2
  | "baz" -> 3
  | "qux" -> 4
  | _ -> 0 ;;
#+END_SRC

#+BEGIN_SRC ocaml
fun i -> match i with 0 -> 1 ;;
#+END_SRC

Pairs and Tuples

#+BEGIN_SRC ocaml
(1, "one", 'k') ;;

([], false) ;;

let snd p =
  match p with
  | (_, y) -> y ;;

snd (42, "apple") ;;
#+end_src

Enumerated Data Type

#+begin_src ocaml
type primary_colour = Red | Green | Blue ;;

[Red; Blue; Red] ;;
#+end_src

Union Data Type

#+BEGIN_SRC ocaml
type http_response =
  | Data of string
  | Error_code of int ;;

Data "<!DOCTYPE html>
<html lang=\"en\">
  <head>
    <meta charset=\"utf-8\">
    <title>Dummy</title>
  </head>
  <body>
    Dummy Page
  </body>
</html>";;

Error_code 404;;
#+END_SRC

Pattern matching on Variants

#+BEGIN_SRC ocaml
 type page_range =
    | All
    | Current
    | Range of int * int;;

let colour_to_rgb colour =
  match colour with
  | Red   -> (0xff,    0,    0)
  | Green -> (0,    0xff,    0)
  | Blue  -> (0,       0, 0xff) ;;

let http_status_code response = 
  match response with
  | Data _ -> 200
  | Error_code code -> code ;;

let is_printable page_count cur range =
  match range with 
  | All -> true 
  | Current -> 0 <= cur && cur < page_count
  | Range (lo, hi) -> 0 <= lo && lo <= hi && hi < page_count ;;
#+END_SRC

Records

#+BEGIN_SRC ocaml
type person = {
  first_name : string;
  surname : string ;
  age : int
} ;;

let gerard = {
  first_name = "Gerard" ;
  surname = "Huet" ;
  age = 76
} ;;

let s = gerard.surname ;;

let is_teenager person =
  match person with
  | { age = x; _ } -> 13 <= x && x <= 19 ;;

is_teenager gerard ;;
#+END_SRC

Exceptions

#+BEGIN_SRC ocaml
10 / 0 ;;

let id_42 n = if n <> 42 then raise (Failure "Sorry") else n ;;

id_42 42;;

id_42 5;;

try id_42 0 with Failure _ -> 0 ;;
#+END_SRC

Using Result Type

#+BEGIN_SRC ocaml
#show result ;;

let id_42_res n = if n <> 42 then Error "Sorry" else Ok n ;;

id_42_res 42 ;;

id_42_res 35 ;;

match id_42_res 0 with
  | Ok n -> n
  | Error _ -> 0 ;;
#+END_SRC

Working with Mutable State

#+BEGIN_SRC ocaml
let r = ref 0 ;;

!r ;;

r := 42 ;;

!r ;;
#+END_SRC

#+BEGIN_SRC ocaml
let text = ref "hello " ;;

print_string !text; text := "world!"; print_endline !text ;;
#+END_SRC

Modules and the Standard Library

#+BEGIN_SRC ocaml
#show Option ;;

Option.map ;;

Option.map (fun x -> x * x) ;;

Option.map (fun x -> x * x) None ;;

Option.map (fun x -> x * x) (Some 8) ;;

List.map ;;

List.map (fun x -> x * x );;
#+END_SRC

* 3. Values and Functiosn

Reference: https://ocaml.org/docs/values-and-functions

What is a a Value?

#+BEGIN_SRC ocaml
2 * 21 ;;

int_of_float ;; 

int_of_float (3.14159 *. 2.0) ;;

fun x -> x * x ;;

print_endline ;;

print_endline "Hello!" ;;
#+END_SRC

Global Definitions

#+BEGIN_SRC ocaml
let the_answer = 2 * 3 * 7 ;;
#+END_SRC

Local Definitions

#+BEGIN_SRC ocaml
let d = 2 * 3 in d * 7 ;;

d ;;

let d = 2 * 3 in
let e = d * 7 in
d * e ;;

d ;;

e ;;

let d =
  let e = 2 * 3 in
  e * 5 in
d * 7 ;;

d ;;

e ;;
#+END_SRC

Pattern Matching on Tuples

#+BEGIN_SRC ocaml
List.split ;;

let (x, y) = List.split [(1, 2); (3, 4); (5, 6); (7, 8)] ;;
#+END_SRC

Pattern Matching on Records

#+BEGIN_SRC ocaml
type name  = { first : string; last : string } ;;

let robin = { first = "Robin"; last = "Milner" } ;;

let { first; last } = robin ;;
#+END_SRC

Pattern Matching on Unit

#+BEGIN_SRC ocaml
let () = print_endline "ha ha" ;;
#+END_SRC

Pattern Matching on User-Defined Types

#+BEGIN_SRC ocaml
type live_person = int * name ;;

let age ((years, { first; last }) : live_person) = years ;;
#+END_SRC

Discarding Values using Pattern Matching

#+BEGIN_SRC ocaml
let (_, y) = List.split [(1, 2); (3, 4); (5, 6); (7, 8)] ;;
#+END_SRC

Scopes and Envirnoments

#+BEGIN_SRC ocaml
let twenty = 20 ;;

let ten = 10 in 2 * ten ;;

ten ;;

(1.0 +. sqrt 5.0) /. 2.0 ;;

let _ = (1.0 +. sqrt 5.0) /. 2.0 ;;
#+END_SRC

Inner Shadowing

#+BEGIN_SRC ocaml
let i = 21 ;;

let i = 7 in i * 2 ;;

i ;;
#+END_SRC

Same-Level Shadowing

#+BEGIN_SRC ocaml
let h = 2 * 3 ;;

let e = h * 7 ;;

let h = 7 ;;

e ;;
#+END_SRC

Applying Functions

#+BEGIN_SRC ocaml
max (21 * 2) (int_of_string "713") ;;

String.starts_with ~prefix:"state" "stateless" ;;
#+END_SRC

Application Operator

#+BEGIN_SRC ocaml
sqrt 9.0 ;; 

sqrt @@ 9.0 ;;
#+END_SRC

Pipe Operator

#+BEGIN_SRC ocaml
"81" |> int_of_string 
     |> float_of_int
     |> sqrt 
     |> int_of_float ;;
#+END_SRC

Anonymous Functions

#+BEGIN_SRC ocaml
fun x -> x ;;

fun x -> x * x ;;

fun s t -> s ^ " " ^ t ;;

function [] -> None | x :: _ -> Some x ;;

List.map (fun x -> x * x) [1; 2; 3; 4] ;;
#+END_SRC

Defining Global Functions

#+BEGIN_SRC ocaml
let f = fun x -> x * x ;;

let g x = x * x ;;
#+END_SRC

Defining Local Functions

#+BEGIN_SRC ocaml
let sq x = x * x in sq 7 * sq 7 ;;

sq ;;
#+END_SRC

Closures

#+BEGIN_SRC ocaml
let j = 2 * 3;;

let k x = x * j ;;

k 7 ;;

let j = 7 ;;

k 7 ;;

let m = j * 3 ;;

let max_42 = max 42 ;;
#+END_SRC

Recursive Functions

#+BEGIN_SRC ocaml
let rec fibo n =
  if n <= 1 then n else fibo (n - 1) + fibo (n - 2 ) ;;

let u = List.init 10 Fun.id ;;

List.map fibo u ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec fib_loop m n i =
  if i = 0 then m else fib_loop n (n + m) (i -1) ;;

let fib = fib_loop 0 1 ;;

List.init 10 Fun.id |> List.map fib ;;
#+END_SRC

Defining Functions with Multiple Parameters

#+BEGIN_SRC ocaml
let sweet_cat x y = x ^ " " ^ y ;;

sweet_cat "kitty" "cat" ;;
#+END_SRC

Anonymous Functions with Multiple Parameters

#+BEGIN_SRC ocaml
let sour_cat = fun x -> fun y -> x ^ " " ^ y ;;

sour_cat "kitty" "cat" ;;
#+END_SRC

Partial Application and Closures

#+BEGIN_SRC ocaml
let sour_kitty x = sour_cat "kitty" x ;;

let sweet_kitty = fun x -> sweet_cat "kitty" x ;;

sour_kitty "cat" ;;

sweet_kitty "cat" ;;
#+END_SRC

Types of Functions of Multiple Parameters

#+BEGIN_SRC ocaml
let dummy_cat : string -> (string -> string) = sweet_cat ;;

let bogus_cat : (string -> string) -> string = sweet_cat ;;
#+END_SRC

Tuples as Function Parameters 

#+BEGIN_SRC ocaml
("felix", 1920) ;;

let spicy_cat (x, y) = x ^ " " ^ y ;;

spicy_cat ("hello", "world") ;;
#+END_SRC

Currying and Uncurrying

#+BEGIN_SRC ocaml
let uncurried_cat (x, y) = sweet_cat x y ;;

let curried_cat x y = uncurried_cat (x, y) ;;
#+END_SRC

#+BEGIN_SRC ocaml
string_of_int ;;

print_endline ;;
#+END_SRC

What makes Functions different from other Values

#+BEGIN_SRC ocaml
sqrt ;;

pred ;;

succ ;;

pred = succ ;;
#+END_SRC

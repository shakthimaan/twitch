* 1. Tour of OCaml

Reference: https://ocaml.org/docs/tour-of-ocaml

Integer

#+BEGIN_SRC ocaml
50 ;;
50 * 50 ;;
#+END_SRC

Float

#+BEGIN_SRC ocaml
6.28 ;;
3.14 ;;
#+END_SRC

String

#+BEGIN_SRC ocaml
"This is really disco!" ;;
#+END_SRC

Boolean

#+BEGIN_SRC ocaml
true ;;
#+END_SRC

List of integers

#+BEGIN_SRC ocaml
let u = [1; 2; 3; 4] ;;
#+END_SRC

List of strings

#+BEGIN_SRC ocaml
["this"; "is"; "mambo"] ;;
#+END_SRC

Prepend to List

#+BEGIN_SRC ocaml
5 :: u ;;
#+END_SRC

If else construct

#+BEGIN_SRC ocaml
2 * if "hello" = "world" then 3 else 5 ;;
#+END_SRC

Let binding

#+BEGIN_SRC ocaml
let x = 50 ;;
#+END_SRC

Let scope

#+BEGIN_SRC ocaml
let y = 50 in y * y ;;
y ;;
#+END_SRC

Let in expression

#+BEGIN_SRC ocaml
let a = 1 in
let b = 2 in
  a + b ;;
#+END_SRC

Functions

#+BEGIN_SRC ocaml
let square x = x * x ;;

square 50 ;;

square ;;
#+END_SRC

Anonymous Functions

#+BEGIN_SRC ocaml
fun x -> x * x ;;
#+END_SRC

Partial Function Application

#+BEGIN_SRC ocaml
let cat a b = a ^ " " ^ b ;;

cat "ha" "ha" ;;

let cat_hi = cat "hi" ;;

cat_hi "friend" ;;
#+END_SRC

Higher order functions

#+BEGIN_SRC ocaml
List.map ;;

List.map (fun x -> x * x) ;;

List.map (fun x -> x * x) [0; 1; 2] ;;
#+END_SRC

Side Effects

#+BEGIN_SRC ocaml
print_endline ;;

print_endline "Hello" ;;
#+END_SRC

Recursive Functions

#+BEGIN_SRC ocaml
let rec range lo hi =
  if lo > hi then []
  else lo :: range (lo + 1) hi ;;

range 2 5 ;;
#+END_SRC

Type Conversion and Type-Inference

#+BEGIN_SRC ocaml
2.0 +. 2.0 ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 + 2.5 ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 +. 2.5 ;;
#+END_SRC

#+BEGIN_SRC ocaml
float_of_int 1 *. 2.5 ;;
#+END_SRC

Lists

#+BEGIN_SRC ocaml
[] ;;

[1; 2; 3] ;;

[false; false; true] ;;

[[1;2]; [3]; [4;5;6]] ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 :: [2; 3; 4] ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec sum u =
  match u with
  | [] -> 0
  | x :: v -> x + sum v ;;

sum [1; 4; 3; 2; 5] ;;
#+END_SRC

Polymorphic Functions on Lists

#+BEGIN_SRC ocaml
let rec length u =
  match u with
  | [] -> 0
  | _ :: v -> 1 + length v ;;

length [1; 2; 3; 4] ;;

length ["cow"; "sheep"; "cat"] ;;

length [[]] ;;
#+END_SRC

Higher-Order Function

#+BEGIN_SRC ocaml
let square x = x * x ;;

let rec map f u =
  match u with
  | [] -> []
  | x :: u -> f x :: map f u ;;

map square [1; 2; 3; 4] ;;
#+END_SRC

Pattern Matching (...)

#+BEGIN_SRC ocaml
#show option ;;

let f opt = match opt with
  | None -> None
  | Some None -> None
  | Some (Some x) -> Some x ;;
#+END_SRC

#+BEGIN_SRC ocaml
let g x =
  if x = "foo" then 1
  else if x = "bar" then 2
  else if x = "baz" then 3
  else if x = "qux" then 4
  else 0 ;;

let g' x = match x with
  | "foo" -> 1
  | "bar" -> 2
  | "baz" -> 3
  | "qux" -> 4
  | _ -> 0 ;;
#+END_SRC

#+BEGIN_SRC ocaml
fun i -> match i with 0 -> 1 ;;
#+END_SRC

Pairs and Tuples

#+BEGIN_SRC ocaml
(1, "one", 'k') ;;

([], false) ;;

let snd p =
  match p with
  | (_, y) -> y ;;

snd (42, "apple") ;;
#+end_src

Enumerated Data Type

#+begin_src ocaml
type primary_colour = Red | Green | Blue ;;

[Red; Blue; Red] ;;
#+end_src

Union Data Type

#+BEGIN_SRC ocaml
type http_response =
  | Data of string
  | Error_code of int ;;

Data "<!DOCTYPE html>
<html lang=\"en\">
  <head>
    <meta charset=\"utf-8\">
    <title>Dummy</title>
  </head>
  <body>
    Dummy Page
  </body>
</html>";;

Error_code 404;;
#+END_SRC

Pattern matching on Variants

#+BEGIN_SRC ocaml
 type page_range =
    | All
    | Current
    | Range of int * int;;

let colour_to_rgb colour =
  match colour with
  | Red   -> (0xff,    0,    0)
  | Green -> (0,    0xff,    0)
  | Blue  -> (0,       0, 0xff) ;;

let http_status_code response = 
  match response with
  | Data _ -> 200
  | Error_code code -> code ;;

let is_printable page_count cur range =
  match range with 
  | All -> true 
  | Current -> 0 <= cur && cur < page_count
  | Range (lo, hi) -> 0 <= lo && lo <= hi && hi < page_count ;;
#+END_SRC

Records

#+BEGIN_SRC ocaml
type person = {
  first_name : string;
  surname : string ;
  age : int
} ;;

let gerard = {
  first_name = "Gerard" ;
  surname = "Huet" ;
  age = 76
} ;;

let s = gerard.surname ;;

let is_teenager person =
  match person with
  | { age = x; _ } -> 13 <= x && x <= 19 ;;

is_teenager gerard ;;
#+END_SRC

Exceptions

#+BEGIN_SRC ocaml
10 / 0 ;;

let id_42 n = if n <> 42 then raise (Failure "Sorry") else n ;;

id_42 42;;

id_42 5;;

try id_42 0 with Failure _ -> 0 ;;
#+END_SRC

Using Result Type

#+BEGIN_SRC ocaml
#show result ;;

let id_42_res n = if n <> 42 then Error "Sorry" else Ok n ;;

id_42_res 42 ;;

id_42_res 35 ;;

match id_42_res 0 with
  | Ok n -> n
  | Error _ -> 0 ;;
#+END_SRC

Working with Mutable State

#+BEGIN_SRC ocaml
let r = ref 0 ;;

!r ;;

r := 42 ;;

!r ;;
#+END_SRC

#+BEGIN_SRC ocaml
let text = ref "hello " ;;

print_string !text; text := "world!"; print_endline !text ;;
#+END_SRC

Modules and the Standard Library

#+BEGIN_SRC ocaml
#show Option ;;

Option.map ;;

Option.map (fun x -> x * x) ;;

Option.map (fun x -> x * x) None ;;

Option.map (fun x -> x * x) (Some 8) ;;

List.map ;;

List.map (fun x -> x * x );;
#+END_SRC

* 2. Values and Functions

Reference: https://ocaml.org/docs/values-and-functions

What is a a Value?

#+BEGIN_SRC ocaml
2 * 21 ;;

int_of_float ;; 

int_of_float (3.14159 *. 2.0) ;;

fun x -> x * x ;;

print_endline ;;

print_endline "Hello!" ;;
#+END_SRC

Global Definitions

#+BEGIN_SRC ocaml
let the_answer = 2 * 3 * 7 ;;
#+END_SRC

Local Definitions

#+BEGIN_SRC ocaml
let d = 2 * 3 in d * 7 ;;

d ;;

let d = 2 * 3 in
let e = d * 7 in
d * e ;;

d ;;

e ;;

let d =
  let e = 2 * 3 in
  e * 5 in
d * 7 ;;

d ;;

e ;;
#+END_SRC

Pattern Matching on Tuples

#+BEGIN_SRC ocaml
List.split ;;

let (x, y) = List.split [(1, 2); (3, 4); (5, 6); (7, 8)] ;;
#+END_SRC

Pattern Matching on Records

#+BEGIN_SRC ocaml
type name  = { first : string; last : string } ;;

let robin = { first = "Robin"; last = "Milner" } ;;

let { first; last } = robin ;;
#+END_SRC

Pattern Matching on Unit

#+BEGIN_SRC ocaml
let () = print_endline "ha ha" ;;
#+END_SRC

Pattern Matching on User-Defined Types

#+BEGIN_SRC ocaml
type live_person = int * name ;;

let age ((years, { first; last }) : live_person) = years ;;
#+END_SRC

Discarding Values using Pattern Matching

#+BEGIN_SRC ocaml
let (_, y) = List.split [(1, 2); (3, 4); (5, 6); (7, 8)] ;;
#+END_SRC

Scopes and Envirnoments

#+BEGIN_SRC ocaml
let twenty = 20 ;;

let ten = 10 in 2 * ten ;;

ten ;;

(1.0 +. sqrt 5.0) /. 2.0 ;;

let _ = (1.0 +. sqrt 5.0) /. 2.0 ;;
#+END_SRC

Inner Shadowing

#+BEGIN_SRC ocaml
let i = 21 ;;

let i = 7 in i * 2 ;;

i ;;
#+END_SRC

Same-Level Shadowing

#+BEGIN_SRC ocaml
let h = 2 * 3 ;;

let e = h * 7 ;;

let h = 7 ;;

e ;;
#+END_SRC

Applying Functions

#+BEGIN_SRC ocaml
max (21 * 2) (int_of_string "713") ;;

String.starts_with ~prefix:"state" "stateless" ;;
#+END_SRC

Application Operator

#+BEGIN_SRC ocaml
sqrt 9.0 ;; 

sqrt @@ 9.0 ;;
#+END_SRC

Pipe Operator

#+BEGIN_SRC ocaml
"81" |> int_of_string 
     |> float_of_int
     |> sqrt 
     |> int_of_float ;;
#+END_SRC

Anonymous Functions

#+BEGIN_SRC ocaml
fun x -> x ;;

fun x -> x * x ;;

fun s t -> s ^ " " ^ t ;;

function [] -> None | x :: _ -> Some x ;;

List.map (fun x -> x * x) [1; 2; 3; 4] ;;
#+END_SRC

Defining Global Functions

#+BEGIN_SRC ocaml
let f = fun x -> x * x ;;

let g x = x * x ;;
#+END_SRC

Defining Local Functions

#+BEGIN_SRC ocaml
let sq x = x * x in sq 7 * sq 7 ;;

sq ;;
#+END_SRC

Closures

#+BEGIN_SRC ocaml
let j = 2 * 3;;

let k x = x * j ;;

k 7 ;;

let j = 7 ;;

k 7 ;;

let m = j * 3 ;;

let max_42 = max 42 ;;
#+END_SRC

Recursive Functions

#+BEGIN_SRC ocaml
let rec fibo n =
  if n <= 1 then n else fibo (n - 1) + fibo (n - 2 ) ;;

let u = List.init 10 Fun.id ;;

List.map fibo u ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec fib_loop m n i =
  if i = 0 then m else fib_loop n (n + m) (i -1) ;;

let fib = fib_loop 0 1 ;;

List.init 10 Fun.id |> List.map fib ;;
#+END_SRC

Defining Functions with Multiple Parameters

#+BEGIN_SRC ocaml
let sweet_cat x y = x ^ " " ^ y ;;

sweet_cat "kitty" "cat" ;;
#+END_SRC

Anonymous Functions with Multiple Parameters

#+BEGIN_SRC ocaml
let sour_cat = fun x -> fun y -> x ^ " " ^ y ;;

sour_cat "kitty" "cat" ;;
#+END_SRC

Partial Application and Closures

#+BEGIN_SRC ocaml
let sour_kitty x = sour_cat "kitty" x ;;

let sweet_kitty = fun x -> sweet_cat "kitty" x ;;

sour_kitty "cat" ;;

sweet_kitty "cat" ;;
#+END_SRC

Types of Functions of Multiple Parameters

#+BEGIN_SRC ocaml
let dummy_cat : string -> (string -> string) = sweet_cat ;;

let bogus_cat : (string -> string) -> string = sweet_cat ;;
#+END_SRC

Tuples as Function Parameters 

#+BEGIN_SRC ocaml
("felix", 1920) ;;

let spicy_cat (x, y) = x ^ " " ^ y ;;

spicy_cat ("hello", "world") ;;
#+END_SRC

Currying and Uncurrying

#+BEGIN_SRC ocaml
let uncurried_cat (x, y) = sweet_cat x y ;;

let curried_cat x y = uncurried_cat (x, y) ;;
#+END_SRC

#+BEGIN_SRC ocaml
string_of_int ;;

print_endline ;;
#+END_SRC

What makes Functions different from other Values

#+BEGIN_SRC ocaml
sqrt ;;

pred ;;

succ ;;

pred = succ ;;
#+END_SRC

* 3. Basic Data Types and Pattern Matching

Reference: https://ocaml.org/docs/basic-data-types

Integers

#+BEGIN_SRC ocaml
42 ;;
#+END_SRC

Floats

#+BEGIN_SRC ocaml
let pi = 3.14159 ;;

let tau = 2.0 *. pi ;;

let tau 2 *. pi ;;

let tau = 2 8 pi ;;
#+END_SRC

Boolean

#+BEGIN_SRC ocaml
true ;;

false ;;

false < true ;;

3 * if "foo" = "bar" then 5 else 5 + 2 ;;

3 * match "foo" = "bar" with true -> 5 | false -> 5 + 2 ;;
#+END_SRC

Characters

#+BEGIN_SRC ocaml
'd' ;;  
#+END_SRC

Strings

#+BEGIN_SRC ocaml
"hello" ^ " " ^ "world!" ;;

"buenos dias".[4] ;;
#+END_SRC

Byte Sequences

#+BEGIN_SRC ocaml
String.to_bytes "hello" ;;
#+END_SRC

Arrays

#+BEGIN_SRC ocaml
[| 0; 1; 2; 3; 4; 5 |] ;;

[| 'x'; 'y'; 'z' |] ;;

[| "foo"; "bar"; "baz" |] ;;

[||] ;;

[| 'x'; 'y'; 'z' |].(2) ;;

let letter = [| 'v'; 'x'; 'y'; 'z'|] ;; 

letter.(2) <- 'F' ;;

letter ;;  
#+END_SRC

Lists

#+BEGIN_SRC ocaml
[0; 1; 2; 3; 4; 5 ] ;;

[ 'x'; 'y'; 'z'] ;;

[ "foo"; "bar"; "baz"] ;;

3 :: [] ;;

2 :: 3 :: [] ;;

1 :: 2 :: 3 :: [] ;;

match [1; 2; 3] with
  | x :: u -> x
  | [] -> raise Exit ;;

match [1; 2; 3] with
  | x :: y :: u -> y
  | x :: u -> x
  | [] -> raise Exit ;;  
#+END_SRC

Options

#+BEGIN_SRC ocaml
None ;;

Some 42 ;;

Some "hello" ;;

match Some 42 with None -> raise Exit | Some x -> x ;;
#+END_SRC

Results

#+BEGIN_SRC ocaml
Ok 42 ;;

Error "Sorry" ;;
#+END_SRC

Tuples

#+BEGIN_SRC ocaml
(3, 'K') ;;

fst (3, 'g') ;;

snd (3, 'g') ;;

let f x = match x with (h, i, j, k) -> j ;;

f (42, 'h', true, 2.0) ;;
#+END_SRC

Functions

#+BEGIN_SRC ocaml
fun x -> x * x ;;

fun x -> x * x ;;

(fun x -> x * x) 9 ;;

fun x -> x ;;

(fun x -> x) 42 ;;

(fun x -> x) "This is really disco!" ;;

#+END_SRC

#+BEGIN_SRC ocaml
let f = fun x -> x * x ;;

f 9 ;;

let g x = x * x ;;

g 9 ;;

raise ;; 

fun s r -> s ^ " " ^ r ;;

let mean s r = (s + r) / 2 ;;
#+END_SRC

Unit

#+BEGIN_SRC ocaml
read_line ;;

print_endline ;;
#+END_SRC

User-Defined Types

Use the "type" keyword for defining either:

1. Variant
2. Record
3. Aliases

Enumerated Data Types

#+BEGIN_SRC ocaml
type character_class =
  | Barbarian
  | Bard
  | Cleric
  | Fighter
  | Monk
  | Paladin
  | Ranger
  | Rogue
  | Sorcerer
  | Wizard ;;
#+END_SRC

#+BEGIN_SRC ocaml
type rectitude = Evil | R_Neutral | Good ;;

type firmness = Chaotic | F_Neutral | Lawful ;;

let rectitude_to_french = function
  | Evil -> "Mauvais"
  | R_Neutral -> "Neutre"
  | Good -> "Bon" ;;
#+END_SRC

Represent weekdays and you can do ordering on the values:

#+BEGIN_SRC ocaml
type weekday =
  | Monday
  | Tuesday
  | Wednesday
  | Thursday
  | Friday ;;

type weekend =
  | Saturday
  | Sunday ;;

Monday < Tuesday ;;

Thursday < Wednesday ;;
#+END_SRC

Constructors with Data

#+BEGIN_SRC ocaml
type commit =
  | Hash of string
  | Tag of string
  | Branch of string
  | Head
  | Fetch_head
  | Orig_head
  | Merge_head ;;

Hash "991f6710bad011868d46edb5d609ce251d1d1854";;
#+END_SRC

Using pattern matching to convert a commit to a string:

#+BEGIN_SRC ocaml
let commit_to_string = function
  | Hash sha -> sha
  | Tag name -> name
  | Branch name -> name
  | Head -> "HEAD"
  | Fetch_head -> "FETCH_HEAD"
  | Orig_head -> "ORIG_HEAD"
  | Merge_head -> "MERGE_HEAD" ;;

let commit_to_string' x = match x with
  | Hash sha -> sha
  | Tag name -> name
  | Branch name -> name
  | Head -> "HEAD"
  | Fetch_head -> "FETCH_HEAD"
  | Orig_head -> "ORIG_HEAD"
  | Merge_head -> "MERGE_HEAD" ;;

commit_to_string' (Hash "991f6710bad011868d46edb5d609ce251d1d1854");;
#+END_SRC

Wrapping product types with parenthesis makes them a single parameter:

#+BEGIN_SRC ocaml
type t =
  | C1 of int * bool
  | C2 of (int * bool) ;;

let p = (4, false) ;;

C1 p ;;

C2 p ;;
#+END_SRC

C1 has two parameters (int and bool).
C2 has one parameter of type int * bool.

Recursive Variants

A definition referring to itself is recursive.

#+BEGIN_SRC ocaml
type json =
  | Null
  | Bool of bool
  | Int of int
  | Float of float
  | String of string
  | Array of json list
  | Object of (string * json) list ;;
#+END_SRC

Both Array and Object contain values of json.

Functions with pattern matching on recursive variants are often
recursive functions.

#+BEGIN_SRC ocaml
let rec has_field name = function
  | Array u ->
    List.fold_left (fun b obj -> b || has_field name obj) false u
  | Object u ->
      List.fold_left (fun b (key, obj) -> b || key = name || has_field name obj) false u
  | _ -> false ;;
#+END_SRC

Polymorphic Data Types

The Some constructor of option is polymorphic as it can be Some 42 or
Some "hola".

#+BEGIN_SRC ocaml
#show option ;;

#show list ;;
#+END_SRC

bool and unit are regular variants:

#+BEGIN_SRC ocaml
#show unit ;;

#show bool;;
#+END_SRC

Product types also behave as variant types:

#+BEGIN_SRC ocaml
type ('a, 'b) pair = Pair of 'a * 'b ;;

Pair (42, true) ;;
#+END_SRC

User-Defined Polymorphic

A binary tree:

#+BEGIN_SRC ocaml
type 'a tree =
  | Leaf
  | Node of 'a * 'a tree * 'a tree ;;

     1
   /   \
  2     3

Node (1, Node(2, Leaf, Leaf), Node(3, Leaf, Leaf)) ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec sum = function
  | Leaf -> 0
  | Node (x, left, right) -> x + sum left + sum right ;;

sum (Node (1, Node(2, Leaf, Leaf), Node(3, Leaf, Leaf))) ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec map f = function
  | Leaf -> Leaf
  | Node (x, left, right) -> Node (f x, map f left, map f right) ;;

map (fun x -> x * x) (Node (1, Node (2, Leaf, Leaf), Node (3, Leaf, Leaf))) ;;
#+END_SRC

Records

#+BEGIN_SRC ocaml
type character = {
  name : string;
  level : int;
  race : string;
  class_type : character_class ;
  alignment : firmness * rectitude ;
  armor_class : int ;
} ;;

let ghorghor_bey = {
  name = "Ghorghor Bey" ;
  level = 17 ;
  race = "half-ogre" ;
  class_type = Fighter;
  alignment = (Chaotic, R_Neutral);
  armor_class = -8 ;
} ;;

ghorghor_bey.alignment ;;

ghorghor_bey.class_type ;;

ghorghor_bey.level ;;
#+END_SRC

To create new record with some values changed:

#+BEGIN_SRC ocaml
let togrev = { ghorghor_bey with name = "Togrev"; level = 20; armor_class = -6 } ;;
#+END_SRC

Pattern match on records:

#+BEGIN_SRC ocaml
match ghorghor_bey with { level; _ } -> level ;;
#+END_SRC

Type Aliases

Any type can be given a name:

#+BEGIN_SRC ocaml
type latitude_longitude = float * float ;;
#+END_SRC

A complete example: Mathematical Expressions

To symbolically output:
n * (x + y) = n * x + n * y.

#+BEGIN_SRC ocaml
type expr =
  | Plus of expr * expr
  | Minus of expr * expr
  | Times of expr * expr
  | Divide of expr * expr
  | Var of string ;;

let e = Times (Var "n", Plus (Var "x", Var "y")) ;;

let rec to_string = function
  | Plus (e1, e2) -> "(" ^ to_string e1 ^ " + " ^ to_string e2 ^ ")"
  | Minus (e1, e2) -> "(" ^ to_string e1 ^ " - " ^ to_string e2 ^ ")"
  | Times (e1, e2) -> "(" ^ to_string e1 ^ " * " ^ to_string e2 ^ ")"
  | Divide (e1, e2) -> "(" ^ to_string e1 ^ " / " ^ to_string e2 ^ ")"
  | Var v -> v ;;

let rec distrib = function
  | Times (e1, Plus (e2, e3)) ->
    Plus (Times (distrib e1, distrib e2),
          Times (distrib e1, distrib e3))
  | Times (Plus (e1, e2), e3) ->
    Plus (Times (distrib e1, distrib e3),
          Times (distrib e2, distrib e3))
  | Plus (e1, e2) -> Plus (distrib e1, distrib e2)
  | Minus (e1, e2) -> Minus (distrib e1, distrib e2)
  | Times (e1, e2) -> Times (distrib e1, distrib e2)
  | Divide (e1, e2) -> Divide (distrib e1, distrib e2)
  | Var v -> Var v;;

e |> distrib |> to_string |> print_endline ;;
#+END_SRC

The reverse operation of factoring out the common subexpressions:

n * x + n * y = n * (x + y).

#+BEGIN_SRC ocaml

let top_factorise = function
  | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 ->
      Times (e1, Plus (e2, e4))
  | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 ->
      Times (Plus (e1, e3), e4)
  | e -> e ;;

top_factorise (Plus (Times (Var "n", Var "x"),
                     Times (Var "n", Var "y"))) ;;
#+END_SRC

* 4. Lists

Reference: https://ocaml.org/docs/lists

All elements of a list must be of the same type

#+BEGIN_SRC ocaml
[1; 2; 3] ;;
#+END_SRC

List has a head and tail.

#+BEGIN_SRC ocaml
[] ;;

[false; true; false] ;;

[1; 2; 3] ;;

[[1; 2]; [3; 4]; [5; 6]] ;;
#+END_SRC

The :: or cons operator adds element to the front of the list.

#+BEGIN_SRC ocaml
1 :: [2; 3] ;;
#+END_SRC

The @ operator combines two lists:

#+BEGIN_SRC ocaml
[1] @ [2; 3] ;;
#+END_SRC

** Functions on Lists

Using functions to operate on pattern matching with lists:

#+BEGIN_SRC ocaml
let rec total l =
  match l with
  | [] -> 0
  | h :: t -> h + total t ;;
#+END_SRC

A function to find the length of a list:

#+BEGIN_SRC ocaml
let rec length l =
    match l with
    | [] -> 0
    | _ :: t -> 1 + length t;;

length [1; 2; 3] ;;

length ["cow"; "sheep"; "cat"] ;;

length [[]] ;;
#+END_SRC

In the pattern _ :: t, _ is not inspected as its type is not relevant.

This is a polymorphic function.

A version with the @ operator for append:

#+BEGIN_SRC ocaml
let rec append a b =
  match a with
  | [] -> b
  | h :: t -> h :: append t b;;
#+END_SRC

** Higher Order Functions on Lists

A map example:

#+BEGIN_SRC ocaml
let rec map f l =
    match l with
    | [] -> []
    | h :: t -> f h :: map f t;;
#+END_SRC

#+BEGIN_SRC ocaml
map (fun x -> x * 2) [1; 2; 3];;

map total [[1; 2]; [3; 4]; [5; 6]];;
#+END_SRC

** The Standard Library List Module

*** Maps and Iterators

A map variant for two lists:

#+BEGIN_SRC ocaml
List.map2 ( + ) [1; 2; 3] [4; 5; 6];;
#+END_SRC

#+BEGIN_SRC ocaml
List.iter ;;

List.iter print_endline ["frank"; "james"; "mary"];;
#+END_SRC

#+BEGIN_SRC ocaml
List.iter2 ;;

List.iter2
    (fun a b -> print_endline (a ^ " " ^ b))
    ["frank"; "james"; "mary"]
    ["carter"; "lee"; "jones"];;
#+END_SRC

Notice that map2 and iter2 will fail if the lists are of unequal length:

#+BEGIN_SRC ocaml
List.map2 ( + ) [1; 2; 3] [4; 5];;
#+END_SRC

*** List Scanning

Use function mem to check if an element is a member of a list.

#+BEGIN_SRC ocaml
List.mem ;;

List.mem "frank" ["james"; "frank"; "mary"];;

List.mem [] [[1; 2]; [3]; []; [5]];;
#+END_SRC

To see if all elements are even in a list, you can go over each
element of the list, keeping a boolean check, or use mem:

#+BEGIN_SRC ocaml
let all =
    not (List.mem false (List.map (fun x -> x mod 2 = 0) [2; 4; 6; 8]));;

let any =
    List.mem true (List.map (fun x -> x mod 2 = 0) [1; 2; 3]);;

#+END_SRC

Instead use the standard library useful functions for_all and exists:

#+BEGIN_SRC ocaml
List.for_all (fun x -> x mod 2 = 0) [2; 4; 6; 8];;

List.exists (fun x -> x mod 2 = 0) [1; 2; 3];;
#+END_SRC

The standard library has evolved into its present state with pieces of
frequently-used code turned into useful general functions.

*** List Searching

Find returns the first element of a list matching a given predicate.

#+BEGIN_SRC ocaml
List.find (fun x -> x mod 2 = 0) [1; 2; 3; 4; 5];;

List.find (fun x -> x mod 2 = 0) [1; 3; 5];;
#+END_SRC

The filter function again takes a predicate and tests it against each element in the list.

#+BEGIN_SRC ocaml
List.filter (fun x -> x mod 2 = 0) [1; 2; 3; 4; 5];;
#+END_SRC

Use partition to return a pair of list:

#+BEGIN_SRC ocaml
List.partition (fun x -> x mod 2 = 0) [1; 2; 3; 4; 5];;
#+END_SRC

*** Association Lists

For dictionaries, we can use Map or Hashtbl modules.

For smaller list of pairs, List has useful functions.

#+BEGIN_SRC ocaml
List.assoc ;;

List.assoc 4 [(3, "three"); (1, "one"); (4, "four")] ;;

List.mem_assoc ;;

List.mem_assoc 4 [(3, "three"); (1, "one"); (4, "four")] ;;
#+END_SRC

You can make a list of pairs from a pair of lists and vice versa:

#+BEGIN_SRC ocaml
List.split ;;

List.split [(3, "three"); (1, "one"); (4, "four")] ;; 

List.combine ;;

List.combine [3; 1; 4] ["three"; "one"; "four"];;
#+END_SRC

*** Sorting List

The compare function can compare any two values of like type:

#+BEGIN_SRC ocaml
compare ;;

compare 3 5 ;;

compare 5 3 ;;

compare 5 5 ;;
#+END_SRC

Use List.sort with a comparison function.

#+BEGIN_SRC ocaml
List.sort ;;

List.sort compare [1; 4; 6; 4; 1] ;;
#+END_SRC

#+BEGIN_SRC ocaml
Fun.flip ;;

List.sort compare ["Reynolds"; "Smith"; "Barnes"];;

List.sort (Fun.flip compare) [1; 4; 6; 4; 1];;

List.sort compare [(1, 3); (1, 2); (2, 3); (2, 2)];;

List.sort
    (fun a b -> compare (fst a) (fst b))
    [(1, 3); (1, 2); (2, 3); (2, 2)];;
#+END_SRC

*** Folds

#+BEGIN_SRC ocaml
List.fold_left ;;

List.fold_left ( + ) 0 [1; 2; 3] ;;

(* (+(+(+ 0 1) 2) 3) *)
#+END_SRC

The max function

#+BEGIN_SRC ocaml
max ;;

List.fold_left max min_int [2; 4; 6; 0; 1] ;;
#+END_SRC

The append and map functions using List.fold_right:

#+BEGIN_SRC ocaml
List.fold_right ;;

List.fold_right ( + ) [1; 2; 3] 0 ;;

(*  (+ 1 (+ 2(+ 3 0)))  *)

let append x y =
    List.fold_right (fun e a -> e :: a) x y;;

let map f l =
  List.fold_right (fun e a -> f e :: a) l [] ;;
#+END_SRC

See: https://github.com/hasura/graphql-engine/pull/2933#discussion_r328410592

List.concat to convert a list of lists into a list can be expensive,
since larger and larger items are passed to the @ operator as its
first argument:

#+BEGIN_SRC ocaml
let concat l = List.fold_left ( @ ) [] l ;;
#+END_SRC

More examples:

#+BEGIN_SRC ocaml
let length' l =
    List.fold_left (fun a _ -> a + 1) 0 l;; 

let rev' l =
    List.fold_left (fun a e -> e :: a) [] l;;

let split' l =
    List.fold_right
      (fun (x, y) (xs, ys) -> (x :: xs, y :: ys))
      l
      ([], []);;
#+END_SRC

** Lists and Tail Recursion

For longer lists, the length function may overflow the stack.

Use an accumulating parameter for the length tail-recursive function:

#+BEGIN_SRC ocaml
let rec length acc l =
    match l with
    | [] -> acc
    | _ :: t -> length (acc + 1) t;;

let l = length 0 [1; 2; 3] ;;
#+END_SRC

We can write a wrapper helper function:

#+BEGIN_SRC ocaml
let rec length_inner acc l =
    match l with
    | [] -> acc
    | _ :: t -> length_inner (acc + 1) t;;

let length l = length_inner 0 l;;
#+END_SRC

Or, all in one function:

#+BEGIN_SRC ocaml
let length l =
    let rec length_inner acc l =
      match l with
      | [] -> acc
      | _ :: t -> length_inner (acc + 1) t
    in
      length_inner 0 l;;
#+END_SRC

* 5. Loops and Recursions

Reference: https://ocaml.org/docs/loops-recursion

** For Loops and While Loops

Syntax of for loop:

#+BEGIN_SRC ocaml
for variable = start_value to end_value do
  expression
done

for variable = start_value downto end_value do
  expression
done
#+END_SRC

OCaml does not have break, continue or last statements.

You can throw an exception.

The for loop should evaluate and return unit.

#+BEGIN_SRC ocaml
for i = 1 to 10 do i done ;;
#+END_SRC

Syntax for while:

#+BEGIN_SRC ocaml
while boolean-condition do
  expression
done
#+END_SRC

You cannot break out of while, and while loops are second-class
citizens.

While loops can be used with references.

#+BEGIN_SRC ocaml
let quit_loop = ref false in
  while not !quit_loop do
    print_string "Have you had enough yet? (y/n) ";
    let str = read_line () in
      if str.[0] = 'y' then quit_loop := true
  done ;;
#+END_SRC

** Looping Over Lists

#+BEGIN_SRC ocaml
let my_list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;

let f elem =
  Printf.printf "I am looking at element %d now\n" elem
in
  List.iter f my_list ;;

List.map (( * ) 2) my_list ;;
 #+END_SRC

#+BEGIN_SRC ocaml
let is_even i =
  i mod 2 = 0
in
  List.filter is_even my_list ;;
#+END_SRC

#+BEGIN_SRC ocaml
List.mem 12 my_list ;;
#+END_SRC

List.for_all and List.exists are the "forall" and "exist" operators in
predicate logic.

To operate on two lists, you have iter2, map2, for_all2, exists2 functions.

#+BEGIN_SRC ocaml
List.map2 (fun x y -> x + y) [1; 2; 3] [2; 3; 4] ;;
#+END_SRC

The map and filter functions operate on each individual list elements in isolation.

Fold is like "inserting an operator between each element of the list." 

For example, adding numbers in a list:

#+BEGIN_SRC ocaml
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 ;;
#+END_SRC

Sum of an empty list should be zero, instead of error.

Product of empty list should return one.

To handle left and right-associative operations based on parenthesis,
there are left and right fold operations.

List.fold_right is less efficient.

Define sum and product functions using List.fold_left for integer lists:

#+BEGIN_SRC ocaml
let sum = List.fold_left ( + ) 0 ;;

let product = List.fold_left ( * ) 1 ;;

sum my_list ;;

product my_list ;;
#+END_SRC

Factorial example:

#+BEGIN_SRC ocaml
let rec range a b =
    if a > b then []
    else a :: range (a + 1) b;;

let fact n = product (range 1 n) ;;

fact 10 ;;
#+END_SRC

** Looping Over Strings

String module has String.copy, String.iter functions and more.

** Recursion

Approach 1: Read entire file using really_input method.

This will not work with keyboard input, channels and sockets.

Approach 2: Use a while loop

Approach 3: Use recursion.

Approach 1 code example:

#+BEGIN_SRC ocaml
open Printf

let read_whole_chan chan =
  let len = in_channel_length chan in
  let result = (Bytes.create len) in
    really_input chan result 0 len;
    (Bytes.to_string result)

let read_whole_file filename =
  let chan = open_in filename in
    read_whole_chan chan

let main () =
  let filename = Sys.argv.(1) in
  let str = read_whole_file filename in
    printf "I read %d characters from %s\n" (String.length str) filename ;;
#+END_SRC

Approach 2 code example:

#+BEGIN_SRC ocaml
open Printf

let read_whole_chan chan =
  let buf = Buffer.create 4096 in
  try
    while true do
      let line = input_line chan in
        Buffer.add_string buf line;
        Buffer.add_char buf '\n'
    done;
    assert false (* This is never executed
	                (always raises Assert_failure). *)
  with
    End_of_file -> Buffer.contents buf

let read_whole_file filename =
  let chan = open_in filename in
    read_whole_chan chan

let main () =
  let filename = Sys.argv.(1) in
  let str = read_whole_file filename in
    printf "I read %d characters from %s\n" (String.length str) filename ;;
#+END_SRC

assert false has a polymorphic type, so it will unify with whatever value is returned by the with branch.

Approach 3 code example:
 
#+BEGIN_SRC ocaml
open Printf

let read_whole_chan chan =
  let buf = Buffer.create 4096 in
  let rec loop () =
    let line = input_line chan in
      Buffer.add_string buf line;
      Buffer.add_char buf '\n';
      loop ()
  in
    try loop () with
      End_of_file -> Buffer.contents buf

let read_whole_file filename =
  let chan = open_in filename in
    read_whole_chan chan

let main () =
  let filename = Sys.argv.(1) in
  let str = read_whole_file filename in
  printf "I read %d characters from %s\n" (String.length str) filename ;;
#+END_SRC

The compiler will turn the recursive loop int a real while loop, which
runs in constant stack space because of tail recursion and not cause
stack overflow.

Yes, we should close the channel:

#+BEGIN_SRC ocaml
...
    try loop () with
      End_of_file -> close_in chan; Buffer.contents buf
#+END_SRC

Recursion is great for constructing and examining certain types of
data structures, like trees:

TODO: Later in utop: readdir_no_ex, string_of_filesystem, loop, read_directory etc.

Recursion Example: Maximum Element in a List

#+BEGIN_SRC ocaml
let rec list_max xs =
  match xs with
  | [] -> failwith "list_max called on empty list"
  | [x] -> x
  | x :: remainder -> max x (list_max remainder) ;;

list_max [1; 2; 3; 4; 1] ;;

list_max [] ;;

list_max [5; 4; 3; 2; 1];;

list_max [5; 4; 3; 2; 1; 100] ;;
#+END_SRC

If you want, you can also formally prove that list_max is correct.

Tail Recursion

#+BEGIN_SRC ocaml
let rec range a b =
  if a > b then []
  else a :: range (a + 1) b ;;
#+END_SRC

Rewrite with:

#+BEGIN_SRC ocaml
let rec range a b =
  if a > b then [] else 
    let result = range (a + 1) b in
      a :: result ;;

List.length (range 1 10) ;;

List.length (range 1 1000000) ;;
#+END_SRC

range is not tail-recursive, and hence we can use an accumulator.

#+BEGIN_SRC ocaml

let rec range2 a b accum =
  if a > b then accum
  else range2 (a + 1) b (a :: accum) ;;

let range a b =
  List.rev (range2 a b []) ;;

List.length (range 1 1000000) ;;
#+END_SRC

The following implementation is twice as fast than the previous one
because it does not need to reverse a list:

** Mutable Records, References (Again!) and Arrays

OCaml records:

#+BEGIN_SRC ocaml
type pair_of_ints = {a : int; b : int} ;;

{a = 3; b = 5} ;;

{a = 3 } ;;
#+END_SRC

The record can have a mutable field.

#+BEGIN_SRC ocaml
type name = {name : string; mutable access_count : int} ;;

let print_name name =
  print_endline ("The name is " ^ name.name);
  name.access_count <- name.access_count + 1 ;;

let n = {name = "Richard Jones"; access_count = 0} ;;

n ;;

print_name n ;;

n ;;

print_name n ;;

n ;;

n.name <- "John Smith" ;;
#+END_SRC

References are implemented using records with a mutable contents field.

The definition at https://v2.ocaml.org/api/Stdlib.html#1_References.

#+BEGIN_SRC ocaml
let r = ref 100 ;;
#+END_SRC

Arrays are another mutable structure.

In OCaml, lists are implemented using linked lists and they can be
slow to find the nth element or random access (because of iterating
over a list).

The OCaml Array is a real array.

TODO: Array in utop.

** Mutually Recursive Functions

If we want two functions that call each other:

#+BEGIN_SRC ocaml
let rec even n =
  match n with
  | 0 -> true
  | x -> odd (x - 1) ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec even n =
  match n with
  | 0 -> true
  | x -> odd (x - 1) ;;

let rec odd n =
  match n with
  | 0 -> false
  | x -> even (x - 1);;
#+END_SRC

No "forward prototypes" in OCaml (as seen in C). Use a special syntax:

#+BEGIN_SRC ocaml
 let rec even n =
    match n with
    | 0 -> true
    | x -> odd (x - 1)
  and odd n =
    match n with
    | 0 -> false
    | x -> even (x - 1)  ;;

even 4 ;;
odd 3 ;;

even 5 ;;
odd 6 ;;
#+END_SRC

You can write mutually recursive class definitions and modules.

* 6. Opam Install

Reference: https://ocaml.org/install

Install opam

#+BEGIN_SRC sh
$ bash -c "sh <(curl -fsSL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)"
#+END_SRC

Review: https://ocaml.org/docs/installing-ocaml

Initialise switch

#+BEGIN_SRC sh
$ which opam
$ opam switch

$ opam init
#+END_SRC

Evaluate environment

#+BEGIN_SRC sh
$ eval $(opam env --switch=default)
#+END_SRC

#+BEGIN_SRC sh
$ opam switch
#+END_SRC

#+BEGIN_SRC sh
$ opam list
#+END_SRC

Install OCaml platform tools:

#+BEGIN_SRC sh
$ opam install ocaml-lsp-server odoc ocamlformat utop
#+END_SRC

#+BEGIN_SRC sh
$ opam list
#+END_SRC

Verify utop

#+BEGIN_SRC sh
$ utop
#+END_SRC

Note:
   * for Emacs, add these lines to ~/.emacs:
     (add-to-list 'load-path "/home/shakthi/.opam/default/share/emacs/site-lisp")
     (require 'ocp-indent)

Test read_line () in utop:

#+BEGIN_SRC sh
read_line ;;

read_line () ;;
#+END_SRC

To delete:

#+BEGIN_SRC sh
$ rm -rf .opam
$ rm /usr/local/bin/opam
#+END_SRC

* 7. Introduction to Opam Switches

Reference: https://ocaml.org/docs/opam-switch-introduction

List switches:

#+BEGIN_SRC sh
$ opam switch list
#+END_SRC

Help:

#+BEGIN_SRC sh
$ opam switch --help
#+END_SRC

List available switches

#+BEGIN_SRC sh
$ opam switch list-available
#+END_SRC

Create a new switch:

#+BEGIN_SRC sh
$ opam switch create 4.14 4.14.2
#+END_SRC

Change to a specific switch:

#+BEGIN_SRC sh
$ opam switch 4.14
#+END_SRC

Confirm the switch:

#+BEGIN_SRC sh
$ opam switch
#+END_SRC

#+BEGIN_SRC sh
$ opam list
#+END_SRC

See ~/.opam/4.14 and ~/.opam/default.
* 8. Your First OCaml Program

** Compiling OCaml Programs

OCaml comes with two compilers: one translating sources into native
binaries and another turning sources into a bytecode format.

OCaml also comes with an interpreter for that bytecode format. 

#+BEGIN_SRC sh
$ opam list | grep dune
$ opam exec -- dune init proj hello
#+END_SRC

If already ran eval $(opam env), omit "opam exec --" command.

#+BEGIN_SRC sh
$ dune init proj hello
#+END_SRC

Install tree command to list files and directories:

#+BEGIN_SRC sh
$ sudo apt install tree
#+END_SRC

#+BEGIN_SRC sh
$ cd hello
$ tree
#+END_SRC

bin: executable programs
lib: libraries
test: tests

Dune can be used for:
- running tests
- generate documentation
- produce packaging metadata
- create arbitrary files

The _build folder is where Dune stores all the files it generates.

Build:

#+BEGIN_SRC sh
$ opam exec -- dune build
#+END_SRC

Execute:

#+BEGIN_SRC sh
$ opam exec -- dune exec hello
#+END_SRC

** Watch Mode

#+BEGIN_SRC sh
$ opam exec -- dune build -w

OR

$ opam exec -- dune exec hello -w
#+END_SRC

** Why Isn't There a Main Function?

There is no requirement that a project must contain a file with that
name in order to produce an executable.

An executable OCaml file's entry point is its first line.

Statements are just processed in order from top to bottom, each triggering the side effects it may have. 

Definitions are added to the environment. 

A common practice to single out a value that triggers all the side effects and mark it as the intended main entry point. 

In OCaml, that's the role of "let () =".

** Modules and the Standard Library

A module is a collection of named values.

Identical names from distinct modules don't clash.

The standard library is collection of several modules.

Try printf from the Printf module in bin/main.ml as fellows:

#+BEGIN_SRC sh
let () = Printf.printf "%s\n" "Hello, World!"
#+END_SRC

** Every File Defines a Module

Each OCaml file defines a module, once compiled.

References to external moduls create dependencies.

Circular dependencies between modules are not allowed.

To create a module, write a new file lib/en.ml:

#+BEGIN_SRC sh
let v = "Hello, world!"
#+END_SRC

Update bin/main.ml:

#+BEGIN_SRC sh
let () = Printf.printf "%s\n" Hello.En.v
#+END_SRC

Execute:

#+BEGIN_SRC sh
opam exec -- dune exec hello
#+END_SRC

Interactive session using utop

#+BEGIN_SRC sh
$ opam exec -- dune utop
#+END_SRC

#+BEGIN_SRC sh
utop # #show Hello.En ;;
module En : sig val v : string end

utop # #quit ;;
#+END_SRC

If you add a file named hello.ml in the lib folder, Dune will consider
this the whole Hello module and it will make En unreachable.

If you want your module En to be visible, you need to add this in your hello.ml file:

#+BEGIN_SRC sh
module En = En
#+END_SRC

** Defining Module Interfaces

UTop's #show command displays an API: the list of definitions provided
by a module.

In OCaml, this is called a modular interface.

An .ml file defines a module.

An .mli file defines a module interface. It must have the same base
name as the module file.

Example: en.mli is the module interface for module en.ml

Create lib/en.mli:

#+BEGIN_SRC sh
val v : string
#+END_SRC

Only the declarations between sig and end from #show output are written.

Module interfaces are also used to create private definitions.

A module definition is private if it is not listed in its
correspending module interface.

Update lib/en.ml:

#+BEGIN_SRC sh
let hello = "Hello"
let v = hello ^ ", world!"
#+END_SRC

Update bin/main.ml

#+BEGIN_SRC sh
let hello = "Hello"
let v = hello ^ ", world!"
#+END_SRC

Try compiling:

#+BEGIN_SRC sh
$ opam exec -- dune exec hello
#+END_SRC

This is because we have not changed lib/en.mli.

"hello" is not there in en.mli and it is private.

** Defining Multiple Modules in a Library

Multiple modules in a single library.

Create lib/es.ml:

#+BEGIN_SRC sh
let v = "Â¡Hola, mundo!"
#+END_SRC

Update bin/main.ml

#+BEGIN_SRC sh
let () = Printf.printf "%s\n" Hello.Es.v
let () = Printf.printf "%s\n" Hello.En.v
#+END_SRC

Execute:

#+BEGIN_SRC sh
$ opam exec -- dune exec hello
#+END_SRC

** Installing and Using Modules from a Package

#+BEGIN_SRC sh
$ opam install dream

$ opam show -f version dream
#+END_SRC

Update bin/main.ml

#+BEGIN_SRC sh
let () = Dream.(run (router [ get "/" (fun (_ : request) -> html Hello.En.v) ]))
#+END_SRC

It responds to HTTP '/' requests with the content of Hello.En.v

Update bin/dune to include the dream library:

#+BEGIN_SRC sh
(executable
 (public_name hello)
 (name main)
 (libraries hello dream))
#+END_SRC

Launch the server:

#+BEGIN_SRC sh
$ opam exec -- dune exec hello
#+END_SRC

Test:

#+BEGIN_SRC sh
$ curl localhost:8080
#+END_SRC

** Using the Preprocessor to Generate Code

We want to display the output as a list of strings.

#+BEGIN_SRC sh
$ opam install ppx_show
#+END_SRC

Update lib/dune:

#+BEGIN_SRC sh
(library
 (name hello)
 (preprocess (pps ppx_show))
 (libraries ppx_show.runtime))
#+END_SRC

Update lib/en.mli:

#+BEGIN_SRC sh
val string_of_string_list : string list -> string
val v : string list
#+END_SRC

Update lib/en.ml:

#+BEGIN_SRC sh
let string_list_pp = [%show: string list]

let string_of_string_list = Format.asprintf "@[%a@]" string_list_pp

let v = String.split_on_char ' ' "Hello using an opam library"
#+END_SRC

v has the type string list. We're using String.split_on_char to turn a
string into a string list by splitting the string on space characters.

string_of_string_list has type string list -> string. This converts a
list of strings into a string, applying the expected formatting.

string_list_pp has type Format.formatter -> string list -> unit, which
means it is a custom formatter that turns a string list into a string

Edit bin/main.ml:

#+BEGIN_SRC sh
let () = print_endline Hello.En.(string_of_string_list v)
#+END_SRC

Execute:

#+BEGIN_SRC sh
$ opam exec -- dune exec hello
#+END_SRC

** Minimum setup

#+BEGIN_SRC sh
$ opam list | grep dune

$ mkdir minimo
$ cd minimo
$ touch dune-project dune minimo.ml
#+END_SRC

dune-project:

#+BEGIN_SRC ocaml
(lang dune 3.14)
#+END_SRC

dune

#+BEGIN_SRC ocaml
(executable (name minimo))
#+END_SRC

minimo.ml

#+BEGIN_SRC ocaml
let () = print_endline "My name is Minimo"
#+END_SRC

Note: minimo.exe is not a file name.

This is how Dune is told to compile the minimo.ml file.

An empty file is valid OCaml syntax.

* 9. utop and IO

A Tour of OCaml

#+BEGIN_SRC ocaml
utop> read_line ;;

utop> read_line () ;;
#+END_SRC

Loops and Recursion

#+BEGIN_SRC ocaml
utop # let quit_loop = ref false in
         while not !quit_loop do
           print_string "Have you had enough yet? (y/n) ";
           let str = read_line () in
             if str.[0] = 'y' then quit_loop := true
         done ;;
Have you had enough yet? (y/n) n
Have you had enough yet? (y/n) n
Have you had enough yet? (y/n) n
Have you had enough yet? (y/n) y
- : unit = ()
#+END_SRC

Note: Use Ctrl + l to clear utop output.

Recursion 
Approach 1

#+BEGIN_SRC ocaml
utop # let read_whole_chan chan =
         let len = in_channel_length chan in
         let result = (Bytes.create len) in
           really_input chan result 0 len;
           (Bytes.to_string result) ;;
val read_whole_chan : in_channel -> string = <fun>

utop # let read_whole_file filename =
         let chan = open_in filename in
           read_whole_chan chan ;;
val read_whole_file : string -> string = <fun>

utop # let main () =
         let filename = "/etc/resolv.conf" in
         let str = read_whole_file filename in
           printf "I read %d characters from %s\n" (String.length str) filename ;;
val main : unit -> unit = <fun>

utop # main () ;;
I read 920 characters from /etc/resolv.conf
- : unit = ()
#+END_SRC

Approach 2

#+BEGIN_SRC ocaml
utop # let read_whole_chan chan =
         let buf = Buffer.create 4096 in
         try
           while true do
             let line = input_line chan in
               Buffer.add_string buf line;
               Buffer.add_char buf '\n'
           done;
           assert false
         with
           End_of_file -> Buffer.contents buf ;;
val read_whole_chan : in_channel -> string = <fun>

utop # main () ;;
I read 920 characters from /etc/resolv.conf
- : unit = ()
#+END_SRC

Approach 3

#+BEGIN_SRC ocaml
utop # let read_whole_chan chan =
         let buf = Buffer.create 4096 in
         let rec loop () =
           let line = input_line chan in
              Buffer.add_string buf line;
              Buffer.add_char buf '\n';
              loop ()
         in
           try loop () with
             End_of_file -> Buffer.contents buf ;;
val read_whole_chan : in_channel -> string = <fun>

utop # main () ;;
I read 920 characters from /etc/resolv.conf
- : unit = ()
#+END_SRC

#+BEGIN_SRC ocaml
utop # type filesystem = File of string | Directory of filesystem list ;;
type filesystem = File of string | Directory of filesystem list

utop # #use "topfind" ;;
- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
utop # #require "unix" ;;

utop # open Unix ;;

utop # let readdir_no_ex dirh =
       try
         Some (readdir dirh)
       with
         End_of_file -> None ;;
val readdir_no_ex : dir_handle -> string option = <fun>

utop # readdir_no_ex ;;
- : dir_handle -> string option = <fun>

utop # let rec string_of_filesystem fs =
       match fs with
       | File filename -> filename ^ "\n"
       | Directory fs_list ->
           List.fold_left (^) "" (List.map string_of_filesystem fs_list) ;;
val string_of_filesystem : filesystem -> string = <fun>

utop # let rec read_directory path =
       let dirh = opendir path in
       let rec loop () =
         let filename = readdir_no_ex dirh in
           match filename with
           | None -> []
           | Some "." -> loop ()
           | Some ".." -> loop ()
           | Some filename ->
               let pathname = path ^ "/" ^ filename in
               let stat = lstat pathname in
               let this =
                 if stat.st_kind = S_DIR then
                   read_directory pathname
                 else
                   File pathname
               in
                 this :: loop ()
       in
         Directory (loop ()) ;;
val read_directory : string -> filesystem = <fun>

utop # read_directory "~" ;;
Exception: Unix.Unix_error(Unix.ENOENT, "opendir", "~")

utop # read_directory "/etc" ;;
Exception: Unix.Unix_error(Unix.EACCES, "opendir", "/etc/cups/ssl")

utop # read_directory "/home/shakthi/code/twitch" ;;

#+END_SRC

Array

#+BEGIN_SRC ocaml
utop # #use "topfind" ;;

utop # #require "base" ;;

utop # open Base ;;

utop # open Array ;;

utop # let a = Array.create 10 0 ;;
Line 1, characters 8-20:
Warning 6 [labels-omitted]: label len was omitted in the application of this function.

val a : int/2 array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]

utop # for i = 0 to Array.length a - 1 do
         a.(i) <- i
       done ;;
- : unit/2 = ()

utop # a ;;
- : int/2 array = [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9|]
#+END_SRC

Matrix Multiplication

Note: Start with new utop session.

#+BEGIN_SRC ocaml

utop # #use "topfind" ;;
- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()

utop # #require "stdio" ;;

utop # open Stdio;;

utop # let size = 30 ;;
val size : int/2 = 30

utop # let mkmatrix rows cols =
       let count = ref 1
       and last_col = cols - 1
       and m = Array.make_matrix rows cols 0 in
         for i = 0 to rows - 1 do
           let mi = m.(i) in
             for j = 0 to last_col do
               mi.(j) <- !count;
               incr count
             done;
         done;
         m ;;

Line 4, characters 15-32:
Warning 6 [labels-omitted]: labels dimx, dimy were omitted in the application of this function.

Line 9, characters 15-19:
Alert deprecated: Base.incr
[2016-09] this element comes from the stdlib distributed with OCaml.
Use [Int.incr] instead.

val mkmatrix : int -> int -> int/2 array array = <fun>

utop # let rec inner_loop k v m1i m2 j =
       if k < 0 then v
       else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j ;;
val inner_loop : int -> int -> int array -> int array array -> int/2 -> int =
  <fun>

utop # let mmult rows cols m1 m2 m3 =
       let last_col = cols - 1
       and last_row = rows - 1 in
         for i = 0 to last_row do
           let m1i = m1.(i) and m3i = m3.(i) in
           for j = 0 to last_col do
             m3i.(j) <- inner_loop last_row 0 m1i m2 j
           done;
         done ;;
val mmult :
  int -> int -> int array array -> int array array -> int array array -> unit/2 =
  <fun>

let () =
  let n =
    try int_of_string "3"
    with Invalid_argument _ -> 1
  and m1 = mkmatrix size size
  and m2 = mkmatrix size size
  and m3 = Array.make_matrix size size 0 in
    for i = 1 to n - 1 do
      mmult size size m1 m2 m3
    done;
    mmult size size m1 m2 m3;
    Printf.printf "%d %d %d %d\n" m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4);;
#+END_SRC
* 10. Labelled and Optional Arguments

Reference: https://ocaml.org/docs/labels

Give names and default values to function parameters. These are known
as labels.

In this tutorial, the parameters that are not labelled are called
positional parameters.

** Passing Labelled Arguments

#+BEGIN_SRC ocaml
utop # Option.value ;;
#+END_SRC

Labelled arguments are passed using a tilde ~ and can be placed at any
position and in any order.

#+BEGIN_SRC ocaml
utop # Option.value (Some 10) ~default:42 ;;
- : int = 10

utop # Option.value ~default:42 (Some 10) ;;
- : int = 10

utop # Option.value ~default:42 None ;;
- : int = 42
#+END_SRC

Passing labelled arguments through the pipe operator will throw a
syntax error:

#+BEGIN_SRC ocaml
utop # ~default:42 |> Option.value None ;;
Error: Syntax error
#+END_SRC

** Labelling Parameters

#+BEGIN_SRC ocaml
utop # let rec range ~first:lo ~last:hi =
       if lo > hi then []
       else lo :: range ~first:(lo + 1) ~last:hi ;;
val range : first:int -> last:int -> int list = <fun>

utop # range ~first:1 ~last:10 ;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]

utop # range ~last:10 ~first:1 ;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
#+END_SRC

The parameters of range are named:

- lo and hi inside the function's body, as usual
- first and last are labels when calling the function.

You can use a shorter syntax:

#+BEGIN_SRC ocaml
utop # let rec range ~first ~last =
       if first > last then []
       else first :: range ~first:(first + 1) ~last ;;
val range : first:int -> last:int -> int list = <fun>

utop # range ~last:10 ~first:1 ;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
#+END_SRC

At parameter definition ~first is the same as ~first:first. Passing
argument ~last is the same as ~last:last.

** Passing Optional Arguments

Optional arguments can be omitted. 

When passed, a tilde ~ or a question mark ? must be used.

They can be placed at any position and in any order.

#+BEGIN_SRC ocaml
utop # let sum ?(init=0) u = List.fold_left ( + ) init u;;
val sum : ?init:int -> int list -> int = <fun>

utop # sum [0; 1; 2; 3; 4; 5];;
- : int = 15

utop # sum [0; 1; 2; 3; 4; 5] ~init:100;;
- : int = 115
#+END_SRC

It is also possible to pass optional arguments as values of type option. 

This is done using a question mark when passing the argument.

#+BEGIN_SRC ocaml
utop # sum [0; 1; 2; 3; 4; 5] ?init:(Some 100);;
- : int = 115

utop # sum [0; 1; 2; 3; 4; 5] ?init:None;;
- : int = 15
#+END_SRC

** Defining Optional Parameters with Default Values

In the following function, ?init:(x = 0) means that ~init is an
optional parameter that defaults to 0. Inside the function, the
parameter is named x.

#+BEGIN_SRC ocaml
utop # let sum ?init:(x=0) u = List.fold_left ( + ) x u;;
val sum : ?init:int -> int list -> int = <fun>

utop # sum [0; 1; 2; 3; 4; 5] ?init:(Some 100);;
- : int = 115

utop # sum [0; 1; 2; 3; 4; 5] ?init:None;;
- : int = 15
#+END_SRC

** Defining Optional Parameters Without Default Values

An optional parameter can be declared without specifying a default value.

#+BEGIN_SRC ocaml
utop # let sub ?(pos=0) ?len:len_opt s =
    let default = String.length s - pos in
    let length = Option.value ~default len_opt in
    String.sub s pos length;;
val sub : ?pos:int -> ?len:int -> string -> string = <fun>
#+END_SRC

We are defining a variant of the function String.sub from the standard library:

- s is the string from which we are extracting a substring.
- pos is the substring's starting position. It defaults to 0.
- len is the substring's length. If missing, it defaults to String.length s - pos.

When an optional parameter is not given a default value, its type inside the function is made an option. 

So, len appears as ?len:int in the function signature. However, inside the body of the function, len_opt is an int option.

#+BEGIN_SRC ocaml
utop # sub ~len:5 ~pos:2 "immutability";;
- : string = "mutab"

utop # sub "immutability" ~pos:7 ;;
- : string = "ility"

utop # sub ~len:2 "immutability";;
- : string = "im"

utop # sub "immutability";;
- : string = "immutability"
#+END_SRC

It is possible to use the same name for the len parameter and label name.

#+BEGIN_SRC ocaml
 let sub ?(pos=0) ?len s =
    let default = String.length s - pos in
    let length = Option.value ~default len in
    String.sub s pos length;;
#+END_SRC

#+BEGIN_SRC ocaml
utop # sub "immutability";;
- : string = "immutability"

utop # sub ~len:2 "immutability";;
- : string = "im"

utop # sub "immutability" ~pos:7 ;;
- : string = "ility"

utop # sub ~len:5 ~pos:2 "immutability";;
- : string = "mutab"
#+END_SRC

** Optional Arguments and Partial Application

Let us compare two variants of the String.concat function.

#+BEGIN_SRC ocaml
utop # let concat_warn ss ?(sep="") = String.concat sep ss;;

utop #  concat_warn ~sep:"--" ["foo"; "bar"; "baz"];;
- : string = "foo--bar--baz"

utop # concat_warn ~sep:"";;
- : string list -> string = <fun>

utop # concat_warn ["foo"; "bar"; "baz"];;
- : ?sep:string -> string = <fun>
#+END_SRC

In the second version, the optional separator is the first declared parameter:

#+BEGIN_SRC ocaml
val concat : ?sep:string -> string list -> string = <fun>

utop # concat ["foo"; "bar"; "baz"] ~sep:"--";;
- : string = "foo--bar--baz"

utop # concat ~sep:"--";;
- : string list -> string = <fun>

utop # concat ["foo"; "bar"; "baz"];;
- : string = "foobarbaz"
#+END_SRC

Only difference is that when only applied to the argument ["foo"; "bar"; "baz"]. In that case:

- concat returns "foobarbaz". The default value "" of ~sep is passed.
- concat_warn returns a partially applied function of type ?sep:string -> string. The default value is not passed.

A function's last declared parameter shouldn't be optional. The
warning suggests turning concat_warn into concat.

Optional parameters make it difficult for the compiler to know if a
function is partially applied or not.

This is why at least one positional parameter is required after the
optional ones.

If present at application, it means the function is fully applied, if
missing, it means the function is partially applied.

** Passing Labelled Arguments Using the Pipe Operator

Declaring a function's unlabelled argument as the first one simplifies
reading the function's type and does not prevent passing this argument
using the pipe operator.

#+BEGIN_SRC ocaml
utop # let rec range step ~first ~last = if first > last then [] else first :: range step ~first:(first + step) ~last;;
val range : int -> first:int -> last:int -> int list = <fun>

utop # 3 |> range ~last:10 ~first:1;;
- : int list = [1; 4; 7; 10]
#+END_SRC

** Function with Only Optional Arguments

When all parameters of a function need to be optional, a dummy,
positional and occurring last parameter must be added.

The unit () value comes in handy for this. 

#+BEGIN_SRC ocaml
utop # let hello ?(who="world") () = "hello, " ^ who;;
val hello : ?who:string -> unit -> string = <fun>

utop # hello ;;
- : ?who:string -> unit -> string = <fun>

utop # hello () ;;
- : string = "hello, world"

utop # hello ~who:"sabine" ;;
- : unit -> string = <fun>

utop # hello ~who:"sabine" () ;;
- : string = "hello, sabine"

utop # hello () ?who:None ;;
- : string = "hello, world"

utop # hello ?who:(Some "christine") () ;;
- : string = "hello, christine"
#+END_SRC

Without the unit parameter, the optional argument cannot be erased warning would be emitted.

** Forwarding an Optional Argument

Passing an optional argument with a question mark sign ? allows forwarding it without unwrapping.

#+BEGIN_SRC ocaml
utop # let take ?len s = sub ?len s;;
val take : ?len:int -> string -> string = <fun>

utop # take "immutability" ~len:2;;
- : string = "im"

utop # let rtake ?off s = sub ?pos:off s;;
val rtake : ?off:int -> string -> string = <fun>

utop # rtake "immutability" ~off:7;;
- : string = "ility"
#+END_SRC

In the definitions of take and rtake, the function sub is called with optional arguments passed with question marks.

In take the optional argument has the same name as in sub; writing ?len is sufficient to forward without unwrapping.

Functions can have named or optional parameters.
* 11. Mutability and Imperative Control Flow

** Immutable vs Mutable Data

The let name-value inding is immutable.

** References

#+BEGIN_SRC ocaml
utop # let d = ref 0 ;;
val d : int ref = {contents = 0}

utop # d ;;
- : int ref = {contents = 0}

utop # d := 1 ;;
- : unit = ()

utop # d ;;
- : int ref = {contents = 1}

utop # !d ;;
- : int = 1
#+END_SRC

The assignment operator := is just a function. It takes

- the reference to be updated, and
- the value that replaces the previous contents.

#+BEGIN_SRC ocaml
utop # ( := ) ;;
- : 'a ref -> 'a -> unit = <fun>
#+END_SRC

The dereference operator is a function that takes a reference and returns its contents.

#+BEGIN_SRC ocaml
utop # ( ! ) ;;
- : 'a ref -> 'a = <fun>
#+END_SRC

** Mutable Record Fields

#+BEGIN_SRC ocaml
type book = {
  series : string;
  volume : int;
  title : string;
  author : string;
  mutable stock : int;
};;
#+END_SRC

A stock inventory example:

#+BEGIN_SRC ocaml
 let vol_7 = {
    series = "Murderbot Diaries";
    volume = 7;
    title = "System Collapse";
    author = "Martha Wells";
    stock = 0
  };;
#+END_SRC

When new stock arrives:

#+BEGIN_SRC ocaml
utop # vol_7.stock <- vol_7.stock + 10 ;;

utop # vol_7 ;;
#+END_SRC

Note: There is no special syntax to dereference a mutable record field.

#+BEGIN_SRC ocaml
utop # #show_type ref ;;
type 'a ref = { mutable contents : 'a; }
#+END_SRC

The type 'a ref is a record with a single field contents, which is
marked with the mutable keyword.

We can define functions create, assign, and deref using the mutable
record field update syntax:

#+BEGIN_SRC ocaml
utop # let create v = { contents = v };;
val create : 'a -> 'a ref = <fun>

utop # let assign f v = f.contents <- v;; 
val assign : 'a ref -> 'a -> unit = <fun>

utop # let deref f = f.contents;;
val deref : 'a ref -> 'a = <fun>

utop # let f = create 0 ;;
val f : int ref = {contents = 0}

utop # deref f ;;
- : int = 0

utop # assign f 2 ;;
- : unit = ()

utop # deref f ;;
- : int = 2
#+END_SRC

The functions:

- create does the same as the ref function provided by the standard library.
- assign does the same as the ( := ) operator.
- deref does the same as the ( ! ) operator.

** Arrays

In OCaml, an array is a mutable, fixed-size data structure that can
store a sequence of elements of the same type.

Arrays are indexed by integers, provide constant-time access, and
allow the update of elements.

#+BEGIN_SRC ocaml
utop # let g = [| 2; 3; 4; 5; 6; 7; 8 |];;
val g : int array = [|2; 3; 4; 5; 6; 7; 8|]

utop # g.(0) ;;
- : int = 2

utop # g.(0) <- 9 ;;
- : unit = ()

utop # g.(0) ;;
- : int = 9

utop # g ;;
- : int array = [|9; 3; 4; 5; 6; 7; 8|]
#+END_SRC

** Byte Sequences

The bytes type in OCaml represents a fixed-length, mutable byte sequence.

Each element has 8 bits.

bytes values are mutable char sequences.

#+BEGIN_SRC ocaml
utop # let h = Bytes.of_string "abcdefghijklmnopqrstuvwxyz";;
val h : bytes = Bytes.of_string "abcdefghijklmnopqrstuvwxyz"

utop # Bytes.get h 10 ;;
- : char = 'k'

utop # Bytes.set h 10 '_' ;;
- : unit = ()

utop # h ;;
- : bytes = Bytes.of_string "abcdefghij_lmnopqrstuvwxyz"
#+END_SRC

Byte sequences can be created from string values using the function
Bytes.of_string.

Note: bytes type uses a much more compact memory representation than
char array.

** Example: get_char Function

We compare two ways to implement a get_char function.

The function waits until a key is pressed and returns the corresponding character without echoing it.

We use two functions from the Unix module to read and update
attributes of the terminal associated with standard input:

tcgetattr stdin TCSAFLUSH returns the terminal attributes as a record (similar to deref)

tcsetattr stdin TCSAFLUSH updates the terminal attributes (similar to assign)

The logic is the same in both implementations:

1. Read and record the terminal attributes
2. Set the terminal attributes
3. Wait until a key is pressed, read it as a character
4. Restore the initial terminal attributes
5. Return the read character

We read characters from standard input using the input_char function
from the OCaml standard library.

#+BEGIN_SRC ocaml
utop # #use "topfind" ;; 

utop # #require "unix" ;;

utop #  let get_char () =
    let open Unix in
    let termio = tcgetattr stdin in
    let c_icanon, c_echo = termio.c_icanon, termio.c_echo in
    termio.c_icanon <- false;
    termio.c_echo <- false;
    tcsetattr stdin TCSAFLUSH termio;
    let c = input_char (in_channel_of_descr stdin) in
    termio.c_icanon <- c_icanon;
    termio.c_echo <- c_echo;
    tcsetattr stdin TCSAFLUSH termio;
    c;;
val get_char : unit -> char = <fun>

utop # get_char () ;;
- : char = 'a'
#+END_SRC

In the second implementation, the record returned by the call to
tcgetattr is not modified.

A copy is made using { termio with c_icanon = false; c_echo = false }.

#+BEGIN_SRC ocaml
utop # let get_char () =
    let open Unix in
    let termio = tcgetattr stdin in
    tcsetattr stdin TCSAFLUSH
      { termio with c_icanon = false; c_echo = false };
    let c = input_char (in_channel_of_descr stdin) in
    tcsetattr stdin TCSAFLUSH termio;
    c;;
val get_char : unit -> char = <fun>

utop # get_char () ;;
- : char = 'b'
#+END_SRC

** Imperative Control Flow

*** Evaluting Expressios in Sequence

Using let ... in construct:

- Names may be bound.
- Side effects take place in sequence

#+BEGIN_SRC ocaml
utop # let () = print_string "This is" in print_endline " really Disco!";;
This is really Disco!
- : unit = ()
#+END_SRC

The single semicolon ; operator is known as the sequence operator.

It allows you to evaluate multiple expressions in order.

#+BEGIN_SRC ocaml
utop # let _ =
  print_endline "Hello,";
  print_endline "world!";
  42;;
Hello,
world!
- : int = 42
#+END_SRC

Even though it is called the sequence operator, the semicolon is not truly an operator.

It is rather a construct of the language. 

It allows adding a semicolon at the end of a sequence expression.

#+BEGIN_SRC ocaml
utop # (); 42; ;;
- : int = 42
#+END_SRC

The semicolon after 42 is ignored.

What we want to do in order:

1. Increment r
2. Compute 2 * !r
3. Assign into r

Use of begin ... end with an example:

#+BEGIN_SRC ocaml
utop # let f r = r := incr 2; 2 * !r ;;
Error: This expression has type int but an expression was expected of type
         int ref

utop # let f r = r := begin incr r; 2 * !r end ;;
val f : int ref -> unit = <fun>
#+END_SRC

#+BEGIN_SRC ocaml
utop # begin end ;;
- : unit = ()
#+END_SRC

*** if ... then ... else ... and Side Effects

#+BEGIN_SRC ocaml
utop #  6 * if "foo" = "bar" then 5 else 5 + 2;;
- : int = 42
#+END_SRC

A conditional expression return type can be unit if both branches are
too.

#+BEGIN_SRC ocaml
utop # if 0 = 1 then print_endline "foo" else print_endline "bar";;
bar
- : unit = ()
#+END_SRC

The above can also be written as:

#+BEGIN_SRC ocaml
utop # print_endline (if 0 = 1 then "foo" else "bar");;
bar
- : unit = ()

utop # if 0 = 1 then print_endline "foo" else ();;
- : unit = ()
#+END_SRC

Without an else branch:

#+BEGIN_SRC ocaml
utop # if 0 = 1 then print_endline "foo";;
- : unit = ()
#+END_SRC

In parsing, conditional expressions groups more than sequencing:

#+BEGIN_SRC ocaml
utop # if true then print_endline "A" else print_endline "B"; print_endline "C";;
A
C
- : unit = ()
#+END_SRC

If you want to have two prints in a conditional expression branch, use begin ... end.

#+BEGIN_SRC ocaml
utop # if true then
   print_endline "A"
 else begin
   print_endline "B";
   print_endline "C"
 end;;
A
- : unit = ()
#+END_SRC

Failing to group in the first branch results in a syntax error.

#+BEGIN_SRC ocaml
utop # if true then
    print_endline "A";
    print_endline "C"
  else
    print_endline "B";;
Error: Syntax error
#+END_SRC

*** For Loop

#+BEGIN_SRC ocaml
utop # for i = 0 to 5 do Printf.printf "%i\n" i done;;
0
1
2
3
4
5
- : unit = ()
#+END_SRC

#+BEGIN_SRC ocaml
let j = [| 2; 3; 4; 5; 6; 7; 8 |];;

utop # for i = Array.length j - 1 downto 0 do 0 done;;
#+END_SRC

For loops are convenient to iterate over and modify arrays:

#+BEGIN_SRC ocaml
utop #  let sum = ref 0 in
  for i = 0 to Array.length j - 1 do sum := !sum + j.(i) done;
  !sum;;
- : int = 35
#+END_SRC

The same using an iterator function:

#+BEGIN_SRC ocaml
 let sum = ref 0 in Array.iter (fun i -> sum := !sum + i) j; !sum;;
#+END_SRC

#+BEGIN_SRC ocaml
utop #  let sum = ref 0 in Array.iter (fun i -> sum := !sum + i) j; !sum;;
- : int = 35
#+END_SRC

*** While Loop

A while loop is an expression of type unit:

#+BEGIN_SRC ocaml
utop # let i = ref 0 in
  while !i <= 5 do
    Printf.printf "%i\n" !i;
    i := !i + 1;
  done;;
0
1
2
3
4
5
- : unit = ()
#+END_SRC

*** Breaking Loops Using Exceptions

Throwing the Exit exception is a recommended way to immediately exit from a loop.

#+BEGIN_SRC ocaml
utop # try
    print_endline "Press Escape to exit";
    while true do
      let c = get_char () in
      if c = '\027' then raise Exit;
      print_char c;
      flush stdout
    done
  with Exit -> ();;
Press Escape to exit
- : unit = ()
#+END_SRC

*** References Inside Closures

The function create_counter returns a closure that hides a mutable
reference n.

#+BEGIN_SRC ocaml
utop # let create_counter () =
  let n = ref 0 in
  fun () -> incr n; !n;;
val create_counter : unit -> unit -> int = <fun>
#+END_SRC

This reference will hold the state of the counter. 

Next, we define a closure that takes no arguments (fun () ->). 

The closure increments the value of n (the counter) using incr n, then
returns the current value of n using !n.

#+BEGIN_SRC ocaml
utop # let c1 = create_counter ();;
val c1 : unit -> int = <fun>

utop # let c2 = create_counter ();;
val c2 : unit -> int = <fun>

utop # c1 () ;;
- : int = 1

utop # c1 () ;;
- : int = 2

utop # c2 () ;;
- : int = 1

utop # c1 () ;;
- : int = 3
#+END_SRC

** Recommendations for Mutable State and Side Effects

We show some patterns and anti-patterns relating to mutable states and side effects:

*** Good: Function-Encapsulated Mutability

No mutability is exposed.

#+BEGIN_SRC ocaml
utop # let sum m =
    let result = ref 0 in
    for i = 0 to Array.length m - 1 do
      result := !result + m.(i)
    done;
    !result;;
val sum : int array -> int = <fun>
#+END_SRC

It is a fully encapsulated implementation choice. 

This function is safe to use.

*** Good: Application-Wide State

Some applications maintain state:
- REPL
- Server for a stateful protocol (session has state).
- Text editor
- Cache

A toy line editor example.

It waits for characters on standard input and exits on end-of-file, carriage return, or newline.

If the character is printable, it prints it and records it in a mutable list used as a stack. 

If the character is the delete code, the stack is popped and the last printed character is erased.

#+BEGIN_SRC ocaml
utop # #use "topfind" ;; 

utop # #require "unix" ;;

utop # let get_char () =
    let open Unix in
    let termio = tcgetattr stdin in
    tcsetattr stdin TCSAFLUSH
      { termio with c_icanon = false; c_echo = false };
    let c = input_char (in_channel_of_descr stdin) in
    tcsetattr stdin TCSAFLUSH termio;
    c;;
val get_char : unit -> char = <fun>

utop # let record_char state c =
    (String.make 1 c, c :: state);;
val record_char : char list -> char -> string * char list = <fun>

utop # let remove_char state =
    ("\b \b", if state = [] then [] else List.tl state);;
val remove_char : 'a list -> string * 'a list = <fun>

utop # let state_to_string state =
    List.(state |> rev |> to_seq |> String.of_seq);;
val state_to_string : char list -> string = <fun>

utop # let rec loop state =
    let c = get_char () in
    if c = '\004' || c = '\n' || c = '\r' then raise Exit;
    let s, new_state = match c with
      | '\127' -> remove_char !state
      | c when c >= ' ' -> record_char !state c
      | _ -> ("", !state) in
    print_string s;
    state := new_state;
    flush stdout;
    loop state;;
val loop : char list ref -> 'a = <fun>
#+END_SRC

#+BEGIN_SRC ocaml
utop # let state = ref [] in try loop state with Exit -> state_to_string !state;;
a- : string = "a"
#+END_SRC

The functions record_char and remove_char neither update the state nor
produce side effects.

They each return a pair of values consisting of a string to print and
the next state, new_state.

I/O and state-update side effects happen inside the loop function.

The state is passed as argument to the loop function.

state-aware code is contained in a narrow scope; the rest of the code
is purely functional.

Note: The state is copied, which is not memory efficient. In a
memory-aware implementation, state-update functions would produce a
“diff”.

*** Good: Precomputing Values

Consider store angles as fractions of the circle in 8-bit unsigned integers, storing them as char values. 

So, 64 is 90 degrees, 128 is 180 degrees, 192 is 270 degrees, 256 is full circle, and so on. 

Compute cosine as follows:

#+BEGIN_SRC ocaml
utop # let char_cos c =
    c |> int_of_char |> float_of_int |> ( *. ) (Float.pi /. 128.0) |> cos;;
val char_cos : char -> float = <fun>

utop # char_cos 'c' ;;
- : float = -0.757208846506484567
#+END_SRC

Make a faster implementation by precomputing all the possible values in advance. 

There are only 256 of them:

#+BEGIN_SRC ocaml
utop # let char_cos_tab = Array.init 256 (fun i -> i |> char_of_int |> char_cos);;

utop # let char_cos c = char_cos_tab.(int_of_char c);;
val char_cos : char -> float = <fun>

utop # char_cos 'c' ;;
- : float = -0.757208846506484567
#+END_SRC

*** Good: Memoization

Memoization uses a cache that is populated when calling the function.

The provided arguments:
- are found in the cache (it is a hit) and the stored result is returned, or they
- are not found in the cache (it's a miss), and the result is computed, stored in the cache, and returned.

*** Good: Functional by Default

OCaml programs should be written in a mostly functional style. 

Avoid side effects where possible and relying on immutable data instead of mutable state.

*** It Depends: Module State

A module may expose or encapsulate a state in several different ways:

Good: expose a type representing a state, with state creation or reset functions

It depends: only expose state initialisation, which implies there only is a single state

Bad: mutable state with no explicit initialisation function or no name referring to the mutable state

Good example: Hashtbl module.

Hashtbl.t represents the mutable data.

Exposes create, clear and reset functions.

The clear and reset functions return unit. 

This strongly signals the reader that they perform the side-effect of
updating the mutable data.

#+BEGIN_SRC ocaml
utop # #show Hashtbl.t ;;
type ('a, 'b) t = ('a, 'b) Hashtbl.t

utop # Hashtbl.create ;;
- : ?random:bool -> int -> ('a, 'b) Hashtbl.t = <fun>

utop # Hashtbl.reset ;;
- : ('a, 'b) Hashtbl.t -> unit = <fun>

utop # Hashtbl.clear ;;
- : ('a, 'b) Hashtbl.t -> unit = <fun>
#+END_SRC

A module may define mutable data internally impacting its behaviour
without exposing it in its interface. This is not advisable.

*** Bad: Undocumented Mutation

#+BEGIN_SRC ocaml
utop # let partition p k =
    let m = Array.copy k in
    let k_len = ref 0 in
    let m_len = ref 0 in
    for i = 0 to Array.length k - 1 do
      if p k.(i) then begin
        k.(!k_len) <- k.(i);
        incr k_len
      end else begin
        m.(!m_len) <- k.(i);
        incr m_len
      end
    done;
    (Array.truncate k_len k, Array.truncate m_len m);;
Error: Unbound value Array.truncate
#+END_SRC

Array.truncate is not defined.

Array.truncate 3 [5; 6; 7; 8; 9] will return [5; 6; 7].

So, the input array is modified. 

This function has a side effect that is either:
- not intended, or
- not documented.

*** Bad: Undocumented Side Effects

#+BEGIN_SRC ocaml
utop # module Array = struct
    include Stdlib.Array
    let copy a =
      if Array.length a > 1000000 then Analytics.collect "Array.copy" a;
      copy a
    end;;
Error: Unbound module Analytics
#+END_SRC

Analytics.collect is a function that makes a network connection to
transmit data to a remote server.

Give the function a descriptive name (for instance,
Array.copy_with_analytics) and document the fact that there's a
side-effect that the caller may not be aware of.

*** Bad: Side Effects Depending on Order of Evaluation

#+BEGIN_SRC ocaml
utop #  let id_print s = print_string (s ^ " "); s;;
val id_print : string -> string = <fun>

utop #  let s =
    Printf.sprintf "%s %s %s"
      (id_print "Monday")
      (id_print "Tuesday")
      (id_print "Wednesday");;
Wednesday Tuesday Monday val s : string = "Monday Tuesday Wednesday"
#+END_SRC

The evaluation order for function arguments in OCaml is not explicitly
defined, the order in which the id_print side effects take place is
unreliable.

In this example, the arguments are evaluated from right to left, but
this could change in future compiler releases.

This also arises when applying arguments to variant constructors,
building tuple values, or initialising record fields.

#+BEGIN_SRC ocaml
utop # let r = ref 0 in ((incr r; !r), (decr r; !r));;
- : int * int = (0, -1)
#+END_SRC

The value of this expression depends on the order of subexpression
evaluation.

Since this order is not specified, there is no reliable way to know
what this value is.

At the time of writing this tutorial, the evaluation produced (0, -1),
but if you see something else, it is not a bug.

Such an unreliable value must a avoided.
* 12. Options

Reference: https://ocaml.org/docs/options

** Introduction

An option value wraps another value or contains nothing if there isn't anything to wrap.

#+BEGIN_SRC ocaml
utop # #show option ;;
type 'a option = None | Some of 'a
#+END_SRC

#+BEGIN_SRC ocaml
utop # Some 42 ;;
- : int option = Some 42

utop # None ;;
- : 'a option = None
#+END_SRC

The option type is useful when the lack of data is better handled as
the special value None rather than an exception.

It is the type-safe version of returning error values.

No confusion between regular values and the absence of a value.

** Exceptions vs Options

Sys.getenv : string -> string from the OCaml standard library queries
the value of an environment variable; however, it throws an exception
if the variable is not defined.

#+BEGIN_SRC ocaml
utop # Sys.getenv "UNDEFINED_ENVIRONMENT_VARIABLE" ;;
Exception: Not_found.
#+END_SRC

Sys.getenv_opt : string -> string option does the same, except it
returns None if the variable is not defined.

#+BEGIN_SRC ocaml
utop # Sys.getenv_opt "UNDEFINED_ENVIRONMENT_VARIABLE" ;;
- : string option = None
#+END_SRC

** The Standard Library Option Module

Most of the functions are provided by Stdlib.Option module.

*** Map Over an Option

Using pattern matching, you can map over an option.

#+BEGIN_SRC ocaml
utop # Option.map ;;
- : ('a -> 'b) -> 'a option -> 'b option = <fun>

utop # Option.map (fun x -> x * x) (Some 3);;
- : int option = Some 9

utop # Option.map (fun x -> x * x) None;;
- : int option = None
#+END_SRC

*** Peel-Off Doubly Wrapped Options

join peels off one layer from a doubly wrapped option:

#+BEGIN_SRC ocaml
utop # Option.join ;;
- : 'a option option -> 'a option = <fun>

utop #  Option.join (Some (Some 42));;
- : int option = Some 42

utop # Option.join (Some None);;
- : 'a option = None

utop # Option.join None;;
- : 'a option = None
#+END_SRC

*** Access the Content of an Option

The function get of type 'a option -> 'a allows access to the value
contained inside an option.

get o throws an exception if o is None. 

To access the content of an option without the risk of raising an
exception, the function value of type 'a option -> 'a -> 'a can be
used:

#+BEGIN_SRC ocaml
utop # Option.get ;;
- : 'a option -> 'a = <fun>

utop # Option.get (Some 42) ;;
- : int = 42
#+END_SRC

Option.value requires a default value as an additional parameter.

#+BEGIN_SRC ocaml
utop # Option.value ;;
- : 'a option -> default:'a -> 'a = <fun>

utop # Option.value (Some 42) ~default:0 ;;
- : int = 42
#+END_SRC

*** Fold an Option

#+BEGIN_SRC ocaml
utop # Option.fold ;;
- : none:'a -> some:('b -> 'a) -> 'b option -> 'a = <fun>
#+END_SRC

A function that turns the contents of the $PATH environment variable into a list of strings, or the empty list if undefined. This version uses pattern matching:

#+BEGIN_SRC ocaml
utop # let path () =
    let split_on_colon = String.split_on_char ':' in
    let opt = Sys.getenv_opt "PATH" in
    match opt with
    | Some s -> split_on_colon s
    | None -> [];;
val path : unit -> string list = <fun>

utop # path () ;;
- : string list =
["/home/shakthi/.opam/default/bin"; "/home/shakthi/.local/bin";
 "/usr/local/sbin"; "/usr/local/bin"; "/usr/sbin"; "/usr/bin"; "/sbin";
 "/bin"; "/usr/games"; "/usr/local/games"; "/snap/bin"; "/snap/bin"]
#+END_SRC

The Option.fold function can be used to implement a fall-back logic
without writing pattern matching. Example:

#+BEGIN_SRC ocaml
utop # let path () =
    let split_on_colon = String.split_on_char ':' in
    Sys.getenv_opt "PATH" |> Option.fold ~some:split_on_colon ~none:[];;
val path : unit -> string list = <fun>

utop # path () ;;
- : string list =
["/home/shakthi/.opam/default/bin"; "/home/shakthi/.local/bin";
 "/usr/local/sbin"; "/usr/local/bin"; "/usr/sbin"; "/usr/bin"; "/sbin";
 "/bin"; "/usr/games"; "/usr/local/games"; "/snap/bin"; "/snap/bin"]
#+END_SRC

*** Bind an Option

The bind function of type 'a option -> ('a -> 'b option) -> 'b option
works a bit like map.

But whilst map expects a function parameter f that returns an
unwrapped value of type b, bind expects an f that returns a value
already wrapped in an option 'b option.

Here, we display the type of Option.map, with parameters flipped and
show a possible implementation of Option.bind.

#+BEGIN_SRC ocaml
utop # Option.map ;;
- : ('a -> 'b) -> 'a option -> 'b option = <fun>

utop # let bind o f = o |> Option.map f |> Option.join;;
val bind : 'a option -> ('a -> 'b option) -> 'b option = <fun>
#+END_SRC

* 13. Arrays

Reference: https://ocaml.org/docs/arrays

Arrays are collections of elements of a single type.

Arrays can be mutated. They cannot be resized.

They are efficient to access elements at any position.

Arrays are commonly used in OCaml for tasks such as:

1. Storing and processing large amounts of data.

2. Implementing algorithms that require random access and modification of elements.

3. Working with matrices and other multi-dimensional data structures.

** Creating Arrays

#+BEGIN_SRC ocaml
utop # [| 1; 2; 3; 4; 5 |] ;;
- : int array = [|1; 2; 3; 4; 5|]
#+END_SRC

Array.make function, which takes two arguments: the length of the array and the initial value of each element.

#+BEGIN_SRC ocaml
utop # Array.make ;;
- : int -> 'a -> 'a array = <fun>

utop #  let zeroes = Array.make 5 0;;
val zeroes : int array = [|0; 0; 0; 0; 0|]
#+END_SRC

Array.init generates an array of a given length by applying a function
to each index of the array, starting at 0.

Example: An array containing the first 5 even numbers using a function
which doubles its argument:

#+BEGIN_SRC ocaml
utop # let even_numbers = Array.init 5 (fun i -> i * 2);;
val even_numbers : int array = [|0; 2; 4; 6; 8|]
#+END_SRC

** Accessing Array Elements

You can access individual elements of an array using the .(index)
syntax.

#+BEGIN_SRC ocaml
utop #  even_numbers.(2);;
- : int = 4
#+END_SRC

** Modifying Array Elements

Assign a new value to an Array using the indexing operator:

#+BEGIN_SRC ocaml
utop # even_numbers.(2) <- 42;;
- : unit = ()

utop # even_numbers ;;
- : int array = [|0; 2; 42; 6; 8|]
#+END_SRC

Note: This operation returns unit, and not the modified array.

** The Standard Library Array Module

*** Length of an Array

Array.length function returns the size of an array:

#+BEGIN_SRC ocaml
utop # Array.length even_numbers;;
- : int = 5
#+END_SRC

*** Iterate on an Array

Array.iter applies a function to each element of an array, one at a time. 

The given function must return unit, operating by side effect. 

#+BEGIN_SRC ocaml
utop # Array.iter (fun x -> print_int x; print_string " ") zeroes;;
0 0 0 0 0 - : unit = ()
#+END_SRC

Iterating on arrays can also be made using for loops:

#+BEGIN_SRC ocaml
utop # for i = 0 to Array.length zeroes - 1 do
    print_int zeroes.(i);
    print_string " "
  done;;
0 0 0 0 0 - : unit = ()
#+END_SRC

*** Map an Array

Array.map function creates a new array by applying a given function to
each element of an array.

#+BEGIN_SRC ocaml
utop # Array.map (fun x -> x * x) even_numbers;;
- : int array = [|0; 4; 1764; 36; 64|]
#+END_SRC

*** Folding an Array

To combine all the elements of an array into a single result, we can
use the Array.fold_left and Array.fold_right functions.

These functions take a binary function, an initial accumulator value, and an array as arguments. 

The binary function takes two arguments: the accumulator's current
value and the current element of the array, then returns a new
accumulator value.

Both functions traverse the array but in opposite directions.

#+BEGIN_SRC ocaml
utop # Array.fold_left ;;
- : ('acc -> 'a -> 'acc) -> 'acc -> 'a array -> 'acc = <fun>

utop # Array.fold_right ;;
- : ('a -> 'acc -> 'acc) -> 'a array -> 'acc -> 'acc = <fun>
#+END_SRC

To find the maximum element of an array:

#+BEGIN_SRC ocaml
utop # Array.fold_left Int.max min_int even_numbers;;
- : int = 42
#+END_SRC

*** Sorting an Array

To sort an array, we can use the Array.sort function. This function takes as arguments:

1. A comparison function.

2. An array, which is sorted in place and in ascending
   order, according to the provided comparison function.

Sorting performed by Array.sort modifies the content of the provided
array, which is why it returns unit.

#+BEGIN_SRC ocaml
utop # Array.sort compare even_numbers;;
- : unit = ()

utop # even_numbers ;;
- : int array = [|0; 2; 6; 8; 42|]
#+END_SRC

** Copying Part of an Aray into Another Array

The Array.blit function efficiently copies a contiguous part of an
array into an array.

This function modifies the destination in place and returns unit, not
the modified array.

#+BEGIN_SRC ocaml
utop # let ones = Array.make 5 1;;
val ones : int array = [|1; 1; 1; 1; 1|]

utop # ones ;;
- : int array = [|1; 1; 1; 1; 1|]

utop # Array.blit ones 0 zeroes 1 2;; 
- : unit = ()

utop # zeroes ;;
- : int array = [|0; 1; 1; 0; 0|]

utop # ones ;;
- : int array = [|1; 1; 1; 1; 1|]
#+END_SRC

This copies two elements of ones, starting at index 0 (this array
slice is [| 1; 1 |]) into zeroes, starting at index 1.

It is your responsibility to make sure that the two indices provided
are valid in their respective arrays and that the number of elements
to copy is within the bounds of each array.

You can also use this function to copy part of an array onto itself:

#+BEGIN_SRC ocaml
utop # zeroes ;;
- : int array = [|0; 1; 1; 0; 0|]

utop # Array.blit ;;
- : 'a array -> int -> 'a array -> int -> int -> unit = <fun>

utop # Array.blit zeroes 1 zeroes 3 2;;
- : unit = ()

utop # zeroes ;;
- : int array = [|0; 1; 1; 1; 1|]
#+END_SRC

This copies two elements of zeroes, starting at index 1 into the last part of zeroes, starting at index 3.


* 14. Sequences

Reference: 

** Introduction

Sequences are very much like lists. 

They may be infinite.

Examples:

1. A stream of incoming requests in a server, 
2. readings from an embedded sensor, 
3. or system logs. 

All have unforeseeable termination, and it is easier to consider them potentially infinite.

The sequence elements are computed on demand and not stored in memory. 

They allow for reducing memory consumption from linear to constant space.

Look at a value of type 'a Seq.t as a list, but when it is not empty:
its tail is frozen.

A mutually recursive definition of Seq.node (a sequence) in the
standard libray:

#+BEGIN_SRC ocaml
type 'a node =
  | Nil
  | Cons of 'a * 'a t
and 'a t = unit -> 'a node
#+END_SRC

Similar to the list definition:

#+BEGIN_SRC ocaml
type 'a list =
  | []
  | (::) of 'a * 'a list
#+END_SRC

The main difference is that Seq.Cons second component's type, which is
a function returning a sequence while its list counterpart is a list.

Comparison:

1. Empty lists and sequences are defined the same way, a constructor
   without any parameters: Seq.Nil and [].

2. Non-empty lists and sequences are both pairs whose former member is
   a piece of data.

3. In lists, it is recursively a list, while in sequences, it is a
   function returning a Seq.node.

A value of type Seq.t is “frozen” because the data it contains isn't
immediately available.

A unit value has to be supplied to recover it, which we may see as
“unfreezing.”

However, unfreezing only gives access to the tip of the sequence,
since the second argument of Seq.Cons is a function too.

Frozen-by-function tails explain why sequences may be considered
potentially infinite.

In OCaml, any value a of type t can be turned into a constant function
by writing fun _ -> a or fun () -> a.

The latter function is called a thunk. 

Using this terminology, Seq.t values are thunks. With the analogy used
earlier, a is frozen in its thunk.

#+BEGIN_SRC ocaml
utop # let rec ints n : int Seq.t = fun () -> Seq.Cons (n, ints (n + 1));;
val ints : int -> int Seq.t = <fun>
#+END_SRC

The function ints n looks as if building the infinite sequence (n; n + 1; n + 2; n + 3;...). 

In reality, since machine integers have bounds, the sequence isn't indefinitely increasing. 

When reaching max_int, it will circle down to min_int.

#+BEGIN_SRC ocaml
utop # max_int ;;
- : int = 4611686018427387903

utop # min_int ;;
- : int = -4611686018427387904
#+END_SRC

The OCaml standard library contains a module on sequences called Seq.

It contains a Seq.iter function, which has the same behaviour as
List.iter.

#+BEGIN_SRC ocaml
Seq.iter print_int (ints 0);;
#+END_SRC

Ctrl+c to interrupt the ekeuction.

#+BEGIN_SRC ocaml
utop # Seq.iter ignore (ints 0);;
#+END_SRC

The key point is: it doesn't leak memory. 

This example is running in constant space. 

It is effectively nothing more than an infinite loop, which can be
confirmed by monitoring the space consumption of the program and by
noticing that it spins forever without crashing.

Whereas a version of this with a list let rec ints n = n :: ints
(n + 1) would allocate a list of length proportional to the running
time, and thus would crash by running out of memory pretty quickly.

#+BEGIN_SRC ocaml
utop # let rec ints n = n :: ints (n + 1) ;;
val ints : int -> int list = <fun>

utop # ints 0 ;;
Stack overflow during evaluation (looping recursion?).
#+END_SRC

** Example

The Seq module of the OCaml standard library contains the definition
of the function Seq.take, which returns a specified number of elements
from the beginning of a sequence. Here is a simplified implementation:

#+BEGIN_SRC ocaml
let rec take n seq () =
  if n <= 0 then
    Seq.Nil
  else
    match seq () with
    | Seq.Cons (x, seq) -> Seq.Cons (x, take (n - 1) seq)
    | _ -> Seq.Nil
#+END_SRC

take n seq returns, at most, the n first elements of the sequence seq. 

If seq contains less than n elements, an identical sequence is returned. 

In particular, if seq is empty, or n is negative, an empty sequence is returned.

The first line of take is a common pattern for recursive functions over sequences. 

The last two parameters are:
1. a sequence called seq
2. a unit value

The function begins by unfreezing seq (that is, calling seq ()) and
then pattern matching to look inside the data made available.

However, this does not happen unless a unit parameter is passed to
take.

Writing take 10 seq does not compute anything.

It is a partial application and returns a function needing a unit to
produce a result.

This can be used to print integers without looping forever:

#+BEGIN_SRC ocaml
utop #  Seq.ints 0 |> Seq.take 43 |> List.of_seq;;
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21;
 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40;
 41; 42]
#+END_SRC

The Seq module also has a function Seq.filter:

#+BEGIN_SRC ocaml
#+END_SRC

It will build a sequence of elements satisfying a condition.

#+BEGIN_SRC ocaml
utop # Seq.filter ;;
- : ('a -> bool) -> 'a Seq.t -> 'a Seq.t = <fun>
#+END_SRC

Using the trial division algorithm, we can define a function which
generates the list of all primes numbers:

#+BEGIN_SRC ocaml
utop # primes |> Seq.take 100 |> List.of_seq;;
- : int list =
[2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71;
 73; 79; 83; 89; 97; 101; 103; 107; 109; 113; 127; 131; 137; 139; 149; 151;
 157; 163; 167; 173; 179; 181; 191; 193; 197; 199; 211; 223; 227; 229; 233;
 239; 241; 251; 257; 263; 269; 271; 277; 281; 283; 293; 307; 311; 313; 317;
 331; 337; 347; 349; 353; 359; 367; 373; 379; 383; 389; 397; 401; 409; 419;
 421; 431; 433; 439; 443; 449; 457; 461; 463; 467; 479; 487; 491; 499; 503;
 509; 521; 523; 541]
#+END_SRC

trial_div is sometimes called corecursive. Although, it may not
terminate, it can indefinitely produce valid output.

** Unfolding Sequences

Standard higher-order iteration functions are available on sequences:

1. Seq.iter
2. Seq.map
3. Seq.fold_left

There is no fold_right function. 

Since OCaml 4.11, there is something which isn't (yet) available on
other types: unfold. Here is how it is implemented:

#+BEGIN_SRC ocaml
utop # let rec unfold f x () = match f x with
  | None -> Seq.Nil
  | Some (x, seq) -> Seq.Cons (x, unfold f seq) ;;
val unfold : ('a -> ('b * 'a) option) -> 'a -> 'b Seq.t = <fun>
#+END_SRC

Seq.unfold does not have a sequence parameter, but a sequence result. 

unfold provides a general means to build sequences. 

The result returned by Seq.unfold f x is the sequence built by
accumulating the results of successive calls to f until it returns
None.

Seq.ints can be implemented using Seq.unfold in a fairly compact way:

#+BEGIN_SRC ocaml
utop # let ints = Seq.unfold (fun n -> Some (n, n + 1));;
val ints : int -> int Seq.t = <fun>
#+END_SRC

map over sequences can be implemented using Seq.unfold. Here is how to
write it:

#+BEGIN_SRC ocaml
utop # let map f = Seq.unfold (fun seq -> seq |> Seq.uncons |> Option.map (fun (x, seq) -> (f x, seq)));;
val map : ('a -> 'b) -> 'a Seq.t -> 'b Seq.t = <fun>
#+END_SRC

#+BEGIN_SRC ocaml
utop # Seq.ints 0 |> map (fun x -> x * x) |> Seq.take 10 |> List.of_seq;;
- : int list = [0; 1; 4; 9; 16; 25; 36; 49; 64; 81]
#+END_SRC

The function Seq.uncons returns the head and tail of a sequence if it
is not empty. Otherwise, it returns None.

#+BEGIN_SRC ocaml
utop # let input_line_opt chan =
  try Some (input_line chan, chan)
  with End_of_file -> None ;;
val input_line_opt : in_channel -> (string * in_channel) option = <fun>

utop # let cin = open_in "/etc/resolv.conf" in
cin |> Seq.unfold input_line_opt |> Seq.iter print_endline;
close_in cin ;;
# This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8).
# Do not edit.
#
# This file might be symlinked as /etc/resolv.conf. If you're looking at
# /etc/resolv.conf and seeing this text, you have followed the symlink.
#
# This is a dynamic resolv.conf file for connecting local clients to the
# internal DNS stub resolver of systemd-resolved. This file lists all
# configured search domains.
#
# Run "resolvectl status" to see details about the uplink DNS servers
# currently in use.
#
# Third party programs should typically not access this file directly, but only
# through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a
# different way, replace this symlink by a static file or a different symlink.
#
# See man:systemd-resolved.service(8) for details about the supported modes of
# operation for /etc/resolv.conf.

nameserver 127.0.0.53
options edns0 trust-ad
search .
- : unit = ()
#+END_SRC

** Sequences are Functions

The Seq module contains this definition:

#+BEGIN_SRC ocaml
val cons : 'a -> 'a Seq.t -> 'a Seq.t
#+END_SRC

Seq.cons is a function and Seq.Cons is a variant's constructor.

If we define the Fibonacci sequence:

#+BEGIN_SRC ocaml
utop # let rec fibs m n = Seq.cons m (fibs n (n + m));;
val fibs : int -> int -> int Seq.t = <fun>

utop # fibs 0 1 ;;
Stack overflow during evaluation (looping recursion?).
#+END_SRC

It is an unending recursion which blows away the stack.

Instead, use Seq.Cons:

#+BEGIN_SRC ocaml
utop # let rec fibs m n () = Seq.Cons (m, fibs n (n + m));;
val fibs : int -> int -> int Seq.t = <fun>

utop # fibs 0 1 |> Seq.take 10 |> List.of_seq;;
- : int list = [0; 1; 1; 2; 3; 5; 8; 13; 21; 34]
#+END_SRC

The difference lies in the recursive call fibs n (n + m). 

In the former definition, the application is complete because fibs is
provided with all the arguments it expects.

In the latter definition, the application is partial because the ()
argument is missing.

Since evaluation is eager in OCaml, in the former case, evaluation of
the recursive call is triggered and a non-terminating looping occurs.

In contrast, in the latter case, the partially applied function is
immediately returned as a closure.

Sequences are functions as stated by their type:

#+BEGIN_SRC ocaml
utop # #show Seq.t ;;
type 'a t = unit -> 'a Seq.node
#+END_SRC

Functions working with sequences must be written accordingly:

Sequence consumer: partially applied function parameter
Sequence producer: partially applied function result

** Sequences for Conversions

Throughout the standard library, sequences are used as a bridge to
perform conversions between many datatypes.

Lists

#+BEGIN_SRC ocaml
val List.of_seq : 'a list -> 'a Seq.t
val List.to_seq : 'a Seq.t -> 'a list
#+END_SRC

Arrays

#+BEGIN_SRC ocaml
val Array.of_seq : 'a array -> 'a Seq.t
val Array.to_seq : 'a Seq.t -> 'a array
#+END_SRC

Strings

#+BEGIN_SRC ocaml
val String.of_seq : string -> char Seq.t
val String.to_seq : char Seq.t -> string
#+END_SRC

Similar functions are also provided for sets, maps, hash tables
(Hashtbl), and others.

When implementing a datatype module, it is advised to expose to_seq
and of_seq functions.

#+BEGIN_SRC ocaml
utop # let range i = List.init i succ ;;
val range : int -> int list = <fun>

utop # range 10 ;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]

utop # range 10 |> List.to_seq ;;
- : int Seq.t = <fun>
#+END_SRC


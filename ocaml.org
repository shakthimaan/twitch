* 1. Tour of OCaml

Reference: https://ocaml.org/docs/tour-of-ocaml

Integer

#+BEGIN_SRC ocaml
50 ;;
50 * 50 ;;
#+END_SRC

Float

#+BEGIN_SRC ocaml
6.28 ;;
3.14 ;;
#+END_SRC

String

#+BEGIN_SRC ocaml
"This is really disco!" ;;
#+END_SRC

Boolean

#+BEGIN_SRC ocaml
true ;;
#+END_SRC

List of integers

#+BEGIN_SRC ocaml
let u = [1; 2; 3; 4] ;;
#+END_SRC

List of strings

#+BEGIN_SRC ocaml
["this"; "is"; "mambo"] ;;
#+END_SRC

Prepend to List

#+BEGIN_SRC ocaml
5 :: u ;;
#+END_SRC

If else construct

#+BEGIN_SRC ocaml
2 * if "hello" = "world" then 3 else 5 ;;
#+END_SRC

Let binding

#+BEGIN_SRC ocaml
let x = 50 ;;
#+END_SRC

Let scope

#+BEGIN_SRC ocaml
let y = 50 in y * y ;;
y ;;
#+END_SRC

Let in expression

#+BEGIN_SRC ocaml
let a = 1 in
let b = 2 in
  a + b ;;
#+END_SRC

Functions

#+BEGIN_SRC ocaml
let square x = x * x ;;

square 50 ;;

square ;;
#+END_SRC

Anonymous Functions

#+BEGIN_SRC ocaml
fun x -> x * x ;;
#+END_SRC

Partial Function Application

#+BEGIN_SRC ocaml
let cat a b = a ^ " " ^ b ;;

cat "ha" "ha" ;;

let cat_hi = cat "hi" ;;

cat_hi "friend" ;;
#+END_SRC

Higher order functions

#+BEGIN_SRC ocaml
List.map ;;

List.map (fun x -> x * x) ;;

List.map (fun x -> x * x) [0; 1; 2] ;;
#+END_SRC

Side Effects

#+BEGIN_SRC ocaml
print_endline ;;

print_endline "Hello" ;;
#+END_SRC

Recursive Functions

#+BEGIN_SRC ocaml
let rec range lo hi =
  if lo > hi then []
  else lo :: range (lo + 1) hi ;;

range 2 5 ;;
#+END_SRC

Type Conversion and Type-Inference

#+BEGIN_SRC ocaml
2.0 +. 2.0 ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 + 2.5 ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 +. 2.5 ;;
#+END_SRC

#+BEGIN_SRC ocaml
float_of_int 1 *. 2.5 ;;
#+END_SRC

Lists

#+BEGIN_SRC ocaml
[] ;;

[1; 2; 3] ;;

[false; false; true] ;;

[[1;2]; [3]; [4;5;6]] ;;
#+END_SRC

#+BEGIN_SRC ocaml
1 :: [2; 3; 4] ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec sum u =
  match u with
  | [] -> 0
  | x :: v -> x + sum v ;;

sum [1; 4; 3; 2; 5] ;;
#+END_SRC

Polymorphic Functions on Lists

#+BEGIN_SRC ocaml
let rec length u =
  match u with
  | [] -> 0
  | _ :: v -> 1 + length v ;;

length [1; 2; 3; 4] ;;

length ["cow"; "sheep"; "cat"] ;;

length [[]] ;;
#+END_SRC

Higher-Order Function

#+BEGIN_SRC ocaml
let square x = x * x ;;

let rec map f u =
  match u with
  | [] -> []
  | x :: u -> f x :: map f u ;;

map square [1; 2; 3; 4] ;;
#+END_SRC

Pattern Matching (...)

#+BEGIN_SRC ocaml
#show option ;;

let f opt = match opt with
  | None -> None
  | Some None -> None
  | Some (Some x) -> Some x ;;
#+END_SRC

#+BEGIN_SRC ocaml
let g x =
  if x = "foo" then 1
  else if x = "bar" then 2
  else if x = "baz" then 3
  else if x = "qux" then 4
  else 0 ;;

let g' x = match x with
  | "foo" -> 1
  | "bar" -> 2
  | "baz" -> 3
  | "qux" -> 4
  | _ -> 0 ;;
#+END_SRC

#+BEGIN_SRC ocaml
fun i -> match i with 0 -> 1 ;;
#+END_SRC

Pairs and Tuples

#+BEGIN_SRC ocaml
(1, "one", 'k') ;;

([], false) ;;

let snd p =
  match p with
  | (_, y) -> y ;;

snd (42, "apple") ;;
#+end_src

Enumerated Data Type

#+begin_src ocaml
type primary_colour = Red | Green | Blue ;;

[Red; Blue; Red] ;;
#+end_src

Union Data Type

#+BEGIN_SRC ocaml
type http_response =
  | Data of string
  | Error_code of int ;;

Data "<!DOCTYPE html>
<html lang=\"en\">
  <head>
    <meta charset=\"utf-8\">
    <title>Dummy</title>
  </head>
  <body>
    Dummy Page
  </body>
</html>";;

Error_code 404;;
#+END_SRC

Pattern matching on Variants

#+BEGIN_SRC ocaml
 type page_range =
    | All
    | Current
    | Range of int * int;;

let colour_to_rgb colour =
  match colour with
  | Red   -> (0xff,    0,    0)
  | Green -> (0,    0xff,    0)
  | Blue  -> (0,       0, 0xff) ;;

let http_status_code response = 
  match response with
  | Data _ -> 200
  | Error_code code -> code ;;

let is_printable page_count cur range =
  match range with 
  | All -> true 
  | Current -> 0 <= cur && cur < page_count
  | Range (lo, hi) -> 0 <= lo && lo <= hi && hi < page_count ;;
#+END_SRC

Records

#+BEGIN_SRC ocaml
type person = {
  first_name : string;
  surname : string ;
  age : int
} ;;

let gerard = {
  first_name = "Gerard" ;
  surname = "Huet" ;
  age = 76
} ;;

let s = gerard.surname ;;

let is_teenager person =
  match person with
  | { age = x; _ } -> 13 <= x && x <= 19 ;;

is_teenager gerard ;;
#+END_SRC

Exceptions

#+BEGIN_SRC ocaml
10 / 0 ;;

let id_42 n = if n <> 42 then raise (Failure "Sorry") else n ;;

id_42 42;;

id_42 5;;

try id_42 0 with Failure _ -> 0 ;;
#+END_SRC

Using Result Type

#+BEGIN_SRC ocaml
#show result ;;

let id_42_res n = if n <> 42 then Error "Sorry" else Ok n ;;

id_42_res 42 ;;

id_42_res 35 ;;

match id_42_res 0 with
  | Ok n -> n
  | Error _ -> 0 ;;
#+END_SRC

Working with Mutable State

#+BEGIN_SRC ocaml
let r = ref 0 ;;

!r ;;

r := 42 ;;

!r ;;
#+END_SRC

#+BEGIN_SRC ocaml
let text = ref "hello " ;;

print_string !text; text := "world!"; print_endline !text ;;
#+END_SRC

Modules and the Standard Library

#+BEGIN_SRC ocaml
#show Option ;;

Option.map ;;

Option.map (fun x -> x * x) ;;

Option.map (fun x -> x * x) None ;;

Option.map (fun x -> x * x) (Some 8) ;;

List.map ;;

List.map (fun x -> x * x );;
#+END_SRC

* 2. Values and Functions

Reference: https://ocaml.org/docs/values-and-functions

What is a a Value?

#+BEGIN_SRC ocaml
2 * 21 ;;

int_of_float ;; 

int_of_float (3.14159 *. 2.0) ;;

fun x -> x * x ;;

print_endline ;;

print_endline "Hello!" ;;
#+END_SRC

Global Definitions

#+BEGIN_SRC ocaml
let the_answer = 2 * 3 * 7 ;;
#+END_SRC

Local Definitions

#+BEGIN_SRC ocaml
let d = 2 * 3 in d * 7 ;;

d ;;

let d = 2 * 3 in
let e = d * 7 in
d * e ;;

d ;;

e ;;

let d =
  let e = 2 * 3 in
  e * 5 in
d * 7 ;;

d ;;

e ;;
#+END_SRC

Pattern Matching on Tuples

#+BEGIN_SRC ocaml
List.split ;;

let (x, y) = List.split [(1, 2); (3, 4); (5, 6); (7, 8)] ;;
#+END_SRC

Pattern Matching on Records

#+BEGIN_SRC ocaml
type name  = { first : string; last : string } ;;

let robin = { first = "Robin"; last = "Milner" } ;;

let { first; last } = robin ;;
#+END_SRC

Pattern Matching on Unit

#+BEGIN_SRC ocaml
let () = print_endline "ha ha" ;;
#+END_SRC

Pattern Matching on User-Defined Types

#+BEGIN_SRC ocaml
type live_person = int * name ;;

let age ((years, { first; last }) : live_person) = years ;;
#+END_SRC

Discarding Values using Pattern Matching

#+BEGIN_SRC ocaml
let (_, y) = List.split [(1, 2); (3, 4); (5, 6); (7, 8)] ;;
#+END_SRC

Scopes and Envirnoments

#+BEGIN_SRC ocaml
let twenty = 20 ;;

let ten = 10 in 2 * ten ;;

ten ;;

(1.0 +. sqrt 5.0) /. 2.0 ;;

let _ = (1.0 +. sqrt 5.0) /. 2.0 ;;
#+END_SRC

Inner Shadowing

#+BEGIN_SRC ocaml
let i = 21 ;;

let i = 7 in i * 2 ;;

i ;;
#+END_SRC

Same-Level Shadowing

#+BEGIN_SRC ocaml
let h = 2 * 3 ;;

let e = h * 7 ;;

let h = 7 ;;

e ;;
#+END_SRC

Applying Functions

#+BEGIN_SRC ocaml
max (21 * 2) (int_of_string "713") ;;

String.starts_with ~prefix:"state" "stateless" ;;
#+END_SRC

Application Operator

#+BEGIN_SRC ocaml
sqrt 9.0 ;; 

sqrt @@ 9.0 ;;
#+END_SRC

Pipe Operator

#+BEGIN_SRC ocaml
"81" |> int_of_string 
     |> float_of_int
     |> sqrt 
     |> int_of_float ;;
#+END_SRC

Anonymous Functions

#+BEGIN_SRC ocaml
fun x -> x ;;

fun x -> x * x ;;

fun s t -> s ^ " " ^ t ;;

function [] -> None | x :: _ -> Some x ;;

List.map (fun x -> x * x) [1; 2; 3; 4] ;;
#+END_SRC

Defining Global Functions

#+BEGIN_SRC ocaml
let f = fun x -> x * x ;;

let g x = x * x ;;
#+END_SRC

Defining Local Functions

#+BEGIN_SRC ocaml
let sq x = x * x in sq 7 * sq 7 ;;

sq ;;
#+END_SRC

Closures

#+BEGIN_SRC ocaml
let j = 2 * 3;;

let k x = x * j ;;

k 7 ;;

let j = 7 ;;

k 7 ;;

let m = j * 3 ;;

let max_42 = max 42 ;;
#+END_SRC

Recursive Functions

#+BEGIN_SRC ocaml
let rec fibo n =
  if n <= 1 then n else fibo (n - 1) + fibo (n - 2 ) ;;

let u = List.init 10 Fun.id ;;

List.map fibo u ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec fib_loop m n i =
  if i = 0 then m else fib_loop n (n + m) (i -1) ;;

let fib = fib_loop 0 1 ;;

List.init 10 Fun.id |> List.map fib ;;
#+END_SRC

Defining Functions with Multiple Parameters

#+BEGIN_SRC ocaml
let sweet_cat x y = x ^ " " ^ y ;;

sweet_cat "kitty" "cat" ;;
#+END_SRC

Anonymous Functions with Multiple Parameters

#+BEGIN_SRC ocaml
let sour_cat = fun x -> fun y -> x ^ " " ^ y ;;

sour_cat "kitty" "cat" ;;
#+END_SRC

Partial Application and Closures

#+BEGIN_SRC ocaml
let sour_kitty x = sour_cat "kitty" x ;;

let sweet_kitty = fun x -> sweet_cat "kitty" x ;;

sour_kitty "cat" ;;

sweet_kitty "cat" ;;
#+END_SRC

Types of Functions of Multiple Parameters

#+BEGIN_SRC ocaml
let dummy_cat : string -> (string -> string) = sweet_cat ;;

let bogus_cat : (string -> string) -> string = sweet_cat ;;
#+END_SRC

Tuples as Function Parameters 

#+BEGIN_SRC ocaml
("felix", 1920) ;;

let spicy_cat (x, y) = x ^ " " ^ y ;;

spicy_cat ("hello", "world") ;;
#+END_SRC

Currying and Uncurrying

#+BEGIN_SRC ocaml
let uncurried_cat (x, y) = sweet_cat x y ;;

let curried_cat x y = uncurried_cat (x, y) ;;
#+END_SRC

#+BEGIN_SRC ocaml
string_of_int ;;

print_endline ;;
#+END_SRC

What makes Functions different from other Values

#+BEGIN_SRC ocaml
sqrt ;;

pred ;;

succ ;;

pred = succ ;;
#+END_SRC

* 3. Basic Data Types and Pattern Matching

Reference: https://ocaml.org/docs/basic-data-types

Integers

#+BEGIN_SRC ocaml
42 ;;
#+END_SRC

Floats

#+BEGIN_SRC ocaml
let pi = 3.14159 ;;

let tau = 2.0 *. pi ;;

let tau 2 *. pi ;;

let tau = 2 8 pi ;;
#+END_SRC

Boolean

#+BEGIN_SRC ocaml
true ;;

false ;;

false < true ;;

3 * if "foo" = "bar" then 5 else 5 + 2 ;;

3 * match "foo" = "bar" with true -> 5 | false -> 5 + 2 ;;
#+END_SRC

Characters

#+BEGIN_SRC ocaml
'd' ;;  
#+END_SRC

Strings

#+BEGIN_SRC ocaml
"hello" ^ " " ^ "world!" ;;

"buenos dias".[4] ;;
#+END_SRC

Byte Sequences

#+BEGIN_SRC ocaml
String.to_bytes "hello" ;;
#+END_SRC

Arrays

#+BEGIN_SRC ocaml
[| 0; 1; 2; 3; 4; 5 |] ;;

[| 'x'; 'y'; 'z' |] ;;

[| "foo"; "bar"; "baz" |] ;;

[||] ;;

[| 'x'; 'y'; 'z' |].(2) ;;

let letter = [| 'v'; 'x'; 'y'; 'z'|] ;; 

letter.(2) <- 'F' ;;

letter ;;  
#+END_SRC

Lists

#+BEGIN_SRC ocaml
[0; 1; 2; 3; 4; 5 ] ;;

[ 'x'; 'y'; 'z'] ;;

[ "foo"; "bar"; "baz"] ;;

3 :: [] ;;

2 :: 3 :: [] ;;

1 :: 2 :: 3 :: [] ;;

match [1; 2; 3] with
  | x :: u -> x
  | [] -> raise Exit ;;

match [1; 2; 3] with
  | x :: y :: u -> y
  | x :: u -> x
  | [] -> raise Exit ;;  
#+END_SRC

Options

#+BEGIN_SRC ocaml
None ;;

Some 42 ;;

Some "hello" ;;

match Some 42 with None -> raise Exit | Some x -> x ;;
#+END_SRC

Results

#+BEGIN_SRC ocaml
Ok 42 ;;

Error "Sorry" ;;
#+END_SRC

Tuples

#+BEGIN_SRC ocaml
(3, 'K') ;;

fst (3, 'g') ;;

snd (3, 'g') ;;

let f x = match x with (h, i, j, k) -> j ;;

f (42, 'h', true, 2.0) ;;
#+END_SRC

Functions

#+BEGIN_SRC ocaml
fun x -> x * x ;;

fun x -> x * x ;;

(fun x -> x * x) 9 ;;

fun x -> x ;;

(fun x -> x) 42 ;;

(fun x -> x) "This is really disco!" ;;

#+END_SRC

#+BEGIN_SRC ocaml
let f = fun x -> x * x ;;

f 9 ;;

let g x = x * x ;;

g 9 ;;

raise ;; 

fun s r -> s ^ " " ^ r ;;

let mean s r = (s + r) / 2 ;;
#+END_SRC

Unit

#+BEGIN_SRC ocaml
read_line ;;

print_endline ;;
#+END_SRC

User-Defined Types

Use the "type" keyword for defining either:

1. Variant
2. Record
3. Aliases

Enumerated Data Types

#+BEGIN_SRC ocaml
type character_class =
  | Barbarian
  | Bard
  | Cleric
  | Fighter
  | Monk
  | Paladin
  | Ranger
  | Rogue
  | Sorcerer
  | Wizard ;;
#+END_SRC

#+BEGIN_SRC ocaml
type rectitude = Evil | R_Neutral | Good ;;

type firmness = Chaotic | F_Neutral | Lawful ;;

let rectitude_to_french = function
  | Evil -> "Mauvais"
  | R_Neutral -> "Neutre"
  | Good -> "Bon" ;;
#+END_SRC

Represent weekdays and you can do ordering on the values:

#+BEGIN_SRC ocaml
type weekday =
  | Monday
  | Tuesday
  | Wednesday
  | Thursday
  | Friday ;;

type weekend =
  | Saturday
  | Sunday ;;

Monday < Tuesday ;;

Thursday < Wednesday ;;
#+END_SRC

Constructors with Data

#+BEGIN_SRC ocaml
type commit =
  | Hash of string
  | Tag of string
  | Branch of string
  | Head
  | Fetch_head
  | Orig_head
  | Merge_head ;;

Hash "991f6710bad011868d46edb5d609ce251d1d1854";;
#+END_SRC

Using pattern matching to convert a commit to a string:

#+BEGIN_SRC ocaml
let commit_to_string = function
  | Hash sha -> sha
  | Tag name -> name
  | Branch name -> name
  | Head -> "HEAD"
  | Fetch_head -> "FETCH_HEAD"
  | Orig_head -> "ORIG_HEAD"
  | Merge_head -> "MERGE_HEAD" ;;

let commit_to_string' x = match x with
  | Hash sha -> sha
  | Tag name -> name
  | Branch name -> name
  | Head -> "HEAD"
  | Fetch_head -> "FETCH_HEAD"
  | Orig_head -> "ORIG_HEAD"
  | Merge_head -> "MERGE_HEAD" ;;

commit_to_string' (Hash "991f6710bad011868d46edb5d609ce251d1d1854");;
#+END_SRC

Wrapping product types with parenthesis makes them a single parameter:

#+BEGIN_SRC ocaml
type t =
  | C1 of int * bool
  | C2 of (int * bool) ;;

let p = (4, false) ;;

C1 p ;;

C2 p ;;
#+END_SRC

C1 has two parameters (int and bool).
C2 has one parameter of type int * bool.

Recursive Variants

A definition referring to itself is recursive.

#+BEGIN_SRC ocaml
type json =
  | Null
  | Bool of bool
  | Int of int
  | Float of float
  | String of string
  | Array of json list
  | Object of (string * json) list ;;
#+END_SRC

Both Array and Object contain values of json.

Functions with pattern matching on recursive variants are often
recursive functions.

#+BEGIN_SRC ocaml
let rec has_field name = function
  | Array u ->
    List.fold_left (fun b obj -> b || has_field name obj) false u
  | Object u ->
      List.fold_left (fun b (key, obj) -> b || key = name || has_field name obj) false u
  | _ -> false ;;
#+END_SRC

Polymorphic Data Types

The Some constructor of option is polymorphic as it can be Some 42 or
Some "hola".

#+BEGIN_SRC ocaml
#show option ;;

#show list ;;
#+END_SRC

bool and unit are regular variants:

#+BEGIN_SRC ocaml
#show unit ;;

#show bool;;
#+END_SRC

Product types also behave as variant types:

#+BEGIN_SRC ocaml
type ('a, 'b) pair = Pair of 'a * 'b ;;

Pair (42, true) ;;
#+END_SRC

User-Defined Polymorphic

A binary tree:

#+BEGIN_SRC ocaml
type 'a tree =
  | Leaf
  | Node of 'a * 'a tree * 'a tree ;;

     1
   /   \
  2     3

Node (1, Node(2, Leaf, Leaf), Node(3, Leaf, Leaf)) ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec sum = function
  | Leaf -> 0
  | Node (x, left, right) -> x + sum left + sum right ;;

sum (Node (1, Node(2, Leaf, Leaf), Node(3, Leaf, Leaf))) ;;
#+END_SRC

#+BEGIN_SRC ocaml
let rec map f = function
  | Leaf -> Leaf
  | Node (x, left, right) -> Node (f x, map f left, map f right) ;;

map (fun x -> x * x) (Node (1, Node (2, Leaf, Leaf), Node (3, Leaf, Leaf))) ;;
#+END_SRC

Records

#+BEGIN_SRC ocaml
type character = {
  name : string;
  level : int;
  race : string;
  class_type : character_class ;
  alignment : firmness * rectitude ;
  armor_class : int ;
} ;;

let ghorghor_bey = {
  name = "Ghorghor Bey" ;
  level = 17 ;
  race = "half-ogre" ;
  class_type = Fighter;
  alignment = (Chaotic, R_Neutral);
  armor_class = -8 ;
} ;;

ghorghor_bey.alignment ;;

ghorghor_bey.class_type ;;

ghorghor_bey.level ;;
#+END_SRC

To create new record with some values changed:

#+BEGIN_SRC ocaml
let togrev = { ghorghor_bey with name = "Togrev"; level = 20; armor_class = -6 } ;;
#+END_SRC

Pattern match on records:

#+BEGIN_SRC ocaml
match ghorghor_bey with { level; _ } -> level ;;
#+END_SRC

Type Aliases

Any type can be given a name:

#+BEGIN_SRC ocaml
type latitude_longitude = float * float ;;
#+END_SRC

A complete example: Mathematical Expressions

To symbolically output:
n * (x + y) = n * x + n * y.

#+BEGIN_SRC ocaml
type expr =
  | Plus of expr * expr
  | Minus of expr * expr
  | Times of expr * expr
  | Divide of expr * expr
  | Var of string ;;

let e = Times (Var "n", Plus (Var "x", Var "y")) ;;

let rec to_string = function
  | Plus (e1, e2) -> "(" ^ to_string e1 ^ " + " ^ to_string e2 ^ ")"
  | Minus (e1, e2) -> "(" ^ to_string e1 ^ " - " ^ to_string e2 ^ ")"
  | Times (e1, e2) -> "(" ^ to_string e1 ^ " * " ^ to_string e2 ^ ")"
  | Divide (e1, e2) -> "(" ^ to_string e1 ^ " / " ^ to_string e2 ^ ")"
  | Var v -> v ;;

let rec distrib = function
  | Times (e1, Plus (e2, e3)) ->
    Plus (Times (distrib e1, distrib e2),
          Times (distrib e1, distrib e3))
  | Times (Plus (e1, e2), e3) ->
    Plus (Times (distrib e1, distrib e3),
          Times (distrib e2, distrib e3))
  | Plus (e1, e2) -> Plus (distrib e1, distrib e2)
  | Minus (e1, e2) -> Minus (distrib e1, distrib e2)
  | Times (e1, e2) -> Times (distrib e1, distrib e2)
  | Divide (e1, e2) -> Divide (distrib e1, distrib e2)
  | Var v -> Var v;;

e |> distrib |> to_string |> print_endline ;;
#+END_SRC

The reverse operation of factoring out the common subexpressions:

n * x + n * y = n * (x + y).

#+BEGIN_SRC ocaml

let top_factorise = function
  | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 ->
      Times (e1, Plus (e2, e4))
  | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 ->
      Times (Plus (e1, e3), e4)
  | e -> e ;;

top_factorise (Plus (Times (Var "n", Var "x"),
                     Times (Var "n", Var "y"))) ;;
#+END_SRC
